{% extends 'articles/base.html' %}

{% block title %}ООП{% endblock %}

{% load static %}

{% block article_content %}
<div class="container">
        <div class="h2_name">
            <p id="Python">Python</p>
        </div>
        <div class="red">
            <p>В этом обучающем материале будут скриншоты кода и результата его исполнения. Это сделано для того,
                чтобы нельзя было скопировать код, а приходилось писать его вручную. Думаю с аксиомой 'пока ты не пишешь - ты не учишься' никто спорить не будет. Для написания кода будет использоваться интегрированная среда разработки <a href="https://www.jetbrains.com/pycharm/" class="links" target="_blink">PyCharm</a>. Используйте тот редактор, к которому привыкли, это не принципиально. Операционная система - Linux, команды, исполняемые в командной строке, тоже будут для Linux. Рекомендую, если вы решили заниматься программированием, начать использовать Linux как можно раньше, установка его рядом с Windows или как единственную систему на вашем устройстве займет пару часов, не затягивайте с этим. Весь код можно найти у меня в github.</p>
        </div>
        <div class="classic_text">
            <h3 class="h3_name">Введение</h3>
            <section class="little_title">Классы</section>
            <p>Объектно-ориентированное программирование построено на классах и на концепциях, или принципах,
                взаимодействия этих классов. Начнем мы знакомство с классов.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_1.png' %}" alt="oop_ls_1"
                 class="python_img i_1">
            <p>Создание класса напоминает создание функции, прописываем ключевое слово class после него пишем название класса и ставим двоеточие. Класс создан.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_1_1.png' %}" alt="oop_ls_1_1"
                 class="python_img i_2">
            <p>Разумеется пустой класс нам не очень интересен. Переименуем наш класс в Computer и создадим три его атрибута: операционная система, тип устройства и операционная память. Для обращения к атрибутам класса проинициализируем его в консоли для наглядности. Таким образом мы можно сказать зарегистрировали наш класс, а вместе с ним и его атрибуты. Теперь к ним можно обратится. Делается это так же, как мы делали с разными методами разных типов данных. Пишем название класса и через точку нам будут показаны все доступные атрибуты этого класса.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_1_2.png' %}" alt="oop_ls_1_2"
                 class="python_img i_3">
            <p>К атрибутам класса можно обратится, а так же можно их изменить.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_1_3.png' %}" alt="oop_ls_1_3"
                 class="python_img i_4">
            <p>Мы можем создавать экземпляры классов. Каждый из экземпляров будет ссылаться на оригинальный класс и
                изменения атрибутов экземпляра класса никак не повлияют на атрибуты оригинального класса. При этом изменения совершаемые над атрибутами в оригинальном классе повлияют на атрибуты его экземпляров, если они не были явно изменены ранее.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_1_4_0.png' %}" alt="oop_ls_1_4_0"
                 class="python_img i_5">
            <p>Мы знаем, что обратиться к атрибуту класса можно через точку, но если мы решим обратиться к
                несуществующему атрибуту, то получим ошибку. Для обращения к атрибутам классов существует функция getattr(). Первым аргументом функция getattr() принимает имя объекта, вторым имя атрибута, а третьим значение по умолчанию, которое будет возвращено, если переданного имени атрибута в пространстве этого объекта не существует.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_1_4.png' %}" alt="oop_ls_1_4"
                 class="python_img i_6">
            <p>Для создания нового атрибута и редактирования уже существующих атрибутов существует функция setattr().
                Первый аргумент - имя объекта, второй - имя атрибута, третий - значение, устанавливаемое в качестве
                нового значения для уже существующего атрибута и в качестве первого значения для несуществующего.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_1_5.png' %}" alt="oop_ls_1_5"
                 class="python_img i_6_1">
            <p>Функция delattr() удаляет атрибут, первый аргумент - имя объекта, второй - имя атрибута.
            <br>Функция hasattr() возвратит True, если атрибут есть в пространстве объекта, а False - если нет,
                первый аргумент - имя объекта, второй - имя атрибута.</p>
            <section class="little_title">Параметр self</section>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_2_1.png' %}" alt="oop_ls_2_1"
                 class="python_img i_7">
            <p>Внутри классов мы можем объявлять методы, в данном случае функция info(). При такой записи pycharm
                показывает нам одну критическую ошибку. Pycharm подсказывает, что метод класса должен иметь
                обязательный параметра, который обычно называется self. Мы можем обратиться к методу класса, но не можем обратиться к этому же методу у экземпляра этого класса. Ошибка подсказывает, что передано ноль аргументов, а должен быть передан один. Тут нам и нужен параметр self. Этот параметр нужен для взаимодействия с экземплярами класса.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_2_2.png' %}" alt="oop_ls_2_2"
                 class="python_img i_8">
            <p>Параметр self, как видно из результата, ссылается на уникальную ячейку памяти выделенную для каждого экземпляра класса.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_2_3.png' %}" alt="oop_ls_2_3"
                 class="python_img i_9">
            <p>Теперь через этот параметр мы можем создавать или менять локальные свойства экземпляров класса.
                Благодаря параметру self интерпретатор понимает к какому экземпляру мы обращаемся. Но pycharm опять
                подсказывает, что мы сделали что-то неправильно. А именно говорит, что не хватает некого инициализатора __init__.</p>
            <section class="little_title">__init__, __new__, __del__</section>
            <p>Методы обрамленные двумя нижними подчеркивании с двух сторон называются магическими или методами
                перегрузки. Их достаточно много и мы постепенно с ними познакомимся. Мы затрагивали пару таких
                методов в разделе по базовому синтаксису, а теперь познакомимся с ними подробнее. И начнем с метода __init__.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_3_1.png' %}" alt="oop_ls_3_1"
                 class="python_img i_10">
            <p>Перепишем наши переменные внутри инициализатора __init__. Метод __init__ выполняет роль конструктора
                класса. Для атрибутов метода __init__ можно прописать значения по умолчанию и тогда можно не
                прописывать их при создании экземпляра класса, а вот значения атрибутов без значения по умолчанию прописывать придется обязательно. Обратится к этим атрибутам можно внутри любого метода данного класса. А благодаря параметру self перед названием атрибута интерпретатор поймет к какому экземпляру класса относится данный атрибут.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_3_2.png' %}" alt="oop_ls_3_2"
                 class="python_img i_11">
            <p>Атрибуты можно не писать внутри параметров самого __init__, ничего не мешает прописать его явно непосредственно в теле __init__, и, конечно, значение такого атрибута при создании экземпляра класса поменять не выйдет.</p>
            <p>Можно подумать, что создание экземпляра класса начинается с метода __init__, но на самом деле
                существует еще один метод, который вызывается перед методом __init__ и вообще перед созданием
                экземпляра класса. Это еще один магический метод - метод __new__. Если углубляться в процесс создания
                экземпляра класса, то станет ясно, что настоящий конструктор это все-таки метод __new__, а __init__
                это, как было сказано выше, инициализатор. Метод __new__ создает экземпляр класса
                и далее передает этот экземпляр в параметр self метода __new__. Для более гибкого
                понимания в каких ситуациях этот метод может быть полезен нужно познакомиться с
                концепцией наследования и функцией super(). Дело в том, что обычно наследования от класса object достаточно для конструирования экземпляров классов. Но вернемся к этому вопросу позже.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_3_3.png' %}" alt="oop_ls_3_3"
                 class="python_img i_12">
            <p>Метод __new__ принимает 3 параметра, cls - обязательный параметр, который
                ссылается на текущий экземпляр класса, и коллекции *args и **kwargs, нужные для
                принятия произвольного количества аргументов передаваемых при создании экземпляра
                класса. В данном случае я закомментировал метод __new__, потому что в таком виде
                он ничего не возвращает, мы увидим лишь его print() при запуске этой программы, а
                остальные команды выполнены не будут, поскольку метод __new__, который ничего не
                возвращает, не создает экземпляр класса. Этот пример нужен лишь для знакомства с синтаксисом этого метода.
                Но в этом примере есть еще один нерассмотренный ранее метод - метод __del__. Если __init__ - инициализатор, то __del__
                - финализатор. __del__ вызывается после того как на объект перестают ссылаться все внешние ссылки. Метод __del__ финальный метод,
                который будет вызван перед удалением экземпляра класса. При чем помещать метод
                __del__ необязателен в конце, он может быть вызван в любом месте тела класса.</p>
            <section class="little_title">Приватные и Публичные методы и атрибуты</section>
            <p>Класс Computer уже поднадоел, давайте создадим новый.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_4_1.png' %}" alt="oop_ls_4_1"
                 class="python_img i_13">
            <p>Класс BankCard, который будет хранить информацию, по которой можно идентифицировать любую банковскую карту. Сейчас все атрибуты и методы этого класса
                являются публичными. Это значит, что мы можем обратиться к методу и получить информацию о карте, а также мы можем обратиться к любому атрибуту
                экземпляра класса напрямую, даже не используя метод. Конечно, для данных, доступ к которым не хотелось бы предоставлять для любого человека,
                такое поведение класса не совсем подходящее. Для таких данных и существует возможность создания приватных методов и атрибутов.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_4_2.png' %}" alt="oop_ls_4_2"
                 class="python_img i_14">
            <p>Для того, чтобы сделать атрибут приватным, достаточно поставить перед его именем два
                нижних подчеркивания. Теперь мы не можем обратиться ни к атрибуту, ни к методу,
                где используются приватные атрибуты, при этом к публичным атрибутам мы по
                прежнему можем обращаться.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_4_3.png' %}" alt="oop_ls_4_3"
                 class="python_img i_15">
            <p>Укажем явно внутри метода на право использования приватных методов и тогда
                получить приватную информацию будет возможно, но только при обращении к соответственному методу. Обратиться к приватным переменным
                напрямую минуя метод по-прежнему будет невозможно, даже написав перед выводом два нижних подчеркивания. Тем самым наши данные становятся инкапсулированными, т.е. скрыты в нашем методе.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_4_4.png' %}" alt="oop_ls_4_4"
                 class="python_img i_16">
            <p>Приватный метод создается также, два нижних подчеркивания перед именем. К такому методу нельзя обратиться вне класса, но можно обратиться
                внутри класса. Таким образом метод __private_info ничего не вернет, а вот метод see_private_info, внутри которого мы обратимся к нашему приватному методу без проблем выведет его содержимое.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_4_5.png' %}" alt="oop_ls_4_5"
                 class="python_img i_17">
            <p>Существует еще один уровень приватности. Он называется - protected. Как видно из скриншота к таким атрибутам и методам мы можем обращаться
                так же как к публичным, ничего этому не препятствует, кроме устного предупреждения от pycharm. Приватность такого уровня используется для разработчиков,
                написав одно нижнее подчеркивание мы указываем другим программистам, которые будут по какой-то причине пользоваться нашим кодом, что эти методы и атрибуты считаются приватными.</p>
            <section class="little_title">Property</section>
            <p>Мы ранее обращались к функциям getattr(), setattr(), delattr(). Теперь немного
                улучшим эти функции.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_5_1.png' %}" alt="oop_ls_5_1"
                 class="python_img i_18">
            <p>Создадим класс CarPrice, у которого будет два атрибута, публичный атрибут name и
                приватный атрибут price. Создадим три метода для взаимодействия с приватным атрибутом, get_price, set_price, del_price. Теперь мы можем вызывать, переопределять и удалять данный атрибут, но каждый
                раз оперировать тремя методами для таких простых действий выглядит достаточно
                нагромождено. Для решения этой проблемы существует функция property().</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_5_2.png' %}" alt="oop_ls_5_2"
                 class="python_img i_19">
            <p>Передадим наши методы в соответствующие атрибуты функции property(). Теперь ко всем трем свойствам мы можем обращаться через одно ключевое слово, в нашем случае слово price. Согласитесь это выглядит
                удобнее. Но можно представить эту запись еще компактнее.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_5_3.png' %}" alt="oop_ls_5_3"
                 class="python_img i_20">
            <p>В первую очередь посмотрим на закомментированные строки. Свойство property можно
                представить таким образом, а далее для избежания конфликта имен и превращения
                этого свойства в декоратор используем для каждого метода одно имя, price в нашем
                случае. Метод get будет являться главным, опишем его как декоратор @property,
                остальные два метода декорируем относительно главного декоратора. Таким образом мы получили достаточно гибкий и элегантный способ работы с приватными атрибутами.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_5_4.png' %}" alt="oop_ls_5_4"
                 class="python_img i_21">
            <p>Посмотрим еще один пример использования property. Создадим класс, который будет
                принимать курс доллара и количество долларов, а возвращать в своем единственном
                методе эквивалент этого значения в рублях. Начнем с метода my_rub_balance, он
                будет производить вычисление каждый раз при его выводе, даже в том случае, если количество и курс не изменился, это не самое хорошее поведение,
                ресурсы расходуются на вычисление результата, который уже известен. Для
                контролирования этого момента создадим проверку. Определим атрибут my_balance и присвоим ей значение None. Таким образом
                получается, если баланс ранее не был вычислен мы его вычислим, если был, то
                просто вернем его. Но отсюда вытекает новая проблема, изменение
                свойства не сбрасывает значение атрибута my_balance. Для решения этой
                проблемы обернем атрибут dol в декораторы @property (или @getter) и @setter, при
                чем внутри сеттера будем каждый раз сбрасывать значение атрибута my_balance.
                Таким образом мы реализовали решение данной задачи таким образом, чтобы текущий
                баланс сохранялся в случае неизменности данных и благодаря этому каждый раз не тратились бы ресурсы устройства на вычисление одного и того же действия.</p>
            <section class="little_title">Паттерн 'Моносостояние'</section>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_6_1.png' %}" alt="oop_ls_6_1"
                 class="python_img i_21">
            <p>Напоминаю, атрибуты создаваемые внутри класса будут присвоены всем атрибутам этого
                класса, но изменение какого-то атрибута повлияет только на локальные свойства
                этого конкретного атрибута, но никак не повлияет на другие экземпляры этого класса. Паттерн 'Моносостояние' решает эту проблему. Метод __dict__, с которым мы ранее не знакомились,
                выводит список всех атрибутов класса, а также его атрибутов. Воспользуемся этой информацией для реализации данного паттерна.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_6_2.png' %}" alt="oop_ls_6_2"
                 class="python_img i_22">
            <p>Реализуем его следующим образом. Создадим приватную переменную, внутрь которой
                поместим словарь с атрибутами нашего класса. А после в инициализаторе __init__ присвоим этот словарь методу __dict__ параметра self. Теперь
                любое изменение любого атрибута любого экземпляра класса повлияет на этот атрибут как в самом классе, так и в каждом его экземпляре.</p>
            <section class="little_title">classmethod и staticmethod</section>
            <p>Ранее мы писали самые обычные методы класса, они принимали обязательный параметр self, который является ссылкой на экземпляр класса, но это не единственный вариант определения методов класса.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_7_1.png' %}" alt="oop_ls_7_1"
                 class="python_img i_23">
            <p>Создадим класс Calculate, у которого будет один собственный атрибут PI равный числу пи. Внутри инициализатора мы создадим один атрибут x,
                который по умолчанию будет равен 30. На строки 10-13 пока не обращаем внимания. Метод square_x() обычный метод, который возвращает квадрат числа.
                А далее прописаны два новых метода.  <br>Статические методы создаются при помощи
                декоратора @staticmethod. Наверное вы уже заметили, что внутри него нет обязательного параметра self и при этом pycharm не видит в такой записи
                никакой ошибки. Статические методы существуют самостоятельно, они не ссылаются ни на какие экземпляры. Вызвать такие методы можно как через сам класс,
                так и через его экземпляры и независимо от способа вызова в такой метод нужно передать обязательные параметры, если таковые требуются. Статический метод
                можно вызывать внутри других методов этого класса. Так например вызовем наш статический метод random(), который возвращает случайное число в диапазоне от 'a' до 'b',
                и в качестве 'a' будем передавать в него наш атрибут 'x', а в качестве 'b' число 100. Проверка будет заключаться в том, что если при переданном 'x' рандомное число в
                диапазоне 'x' - 100 будет выше 50, то мы используем 'x', в противном случае используем число по умолчанию, т.е. 30. Так, например, в первом экземпляре передадим
                число 4 и увидим, что программа в качестве 'x' взяла число 30, это означает, что число из диапазона 4 - 100, выпавшее в результате проверки, больше 50. Во втором
                экземпляре ситуация противоположная, число из диапазона 20 - 100 оказалось меньше 50, поэтому мы использовали в качестве 'x' число 20.<br>Следующий метод - square_circle.
                Это метод класса, о чем говорит декоратор @classmethod. Методы класса можно
                вызывать напрямую от класса. Параметр cls, с которым мы уже сталкивались, как раз является
                ссылкой на класс, в нашем случае на Calculate. Методы класса можно вызывать напрямую через класс, т.е. не передавать ссылку на экземпляр класса. Такой метод может обращаться
                к атрибутам класса, а вот к локальным атрибутам методов класса, например к
                атрибуту 'x', обратиться не выйдет. И возвращать этот конкретный метод класса будет площадь круга. Так же как и
                статический метод мы можем вызвать метод класса внутри другого метода. Так, например, будем вызывать его каждый раз при
                создании каждого нового экземпляра класса, при чем возвращать он будет площадь
                посчитанную для той переменной 'x', которая передана при создании экземпляра, а не той, которая будет выбрана в результате проверки.</p>
            <p>Так же обращаю ваше внимание, названия self и cls, для ссылок на экземпляр и на класс, необязательно должны называться так, это названия принятые
                сообществом, ничего не мешает заменить их на любое другое, их функционал и назначение от этого не изменятся.</p>
            <section class="little_title">__str__, __repr__</section>
            <p>Начнем постепенно знакомиться с наиболее ключевыми магическими методами. По
                другому их называют dunder методы, от английского Double UNDERscore - двойное
                нижнее подчеркивание.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_8_1.png' %}" alt="oop_ls_8_1"
                 class="python_img i_24">
            <p>Начнем знакомство с методов для отображения экземпляров класса. Посмотрим на класс
                Language, если распечатать атрибут функцией print(), то мы увидим не очень дружелюбное для понимания имя.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_8_2.png' %}" alt="oop_ls_8_2"
                 class="python_img i_25">
            <p>Метод __repr__ изменит отображение этого имени в отладочном режиме. Поэтому метод
                __repr__ используется для разработчиков.
            <br>Метод __str__ изменит отображение для пользователей.</p>
            <section class="little_title">__len__, __abs__</section>
            <p>Просто так применять функции len() и abs() к экземплярам класса не выйдет, нужно сначала определить эти методы.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_9_1.png' %}" alt="oop_ls_9_1"
                 class="python_img i_26">
            <p>Метод __len__ соответственно вернет длину объекта.
            <br>А метод __abs__ вернет модуль числа, или говоря по другому, его абсолютное значение.</p>
            <section class="little_title">__add__, __mul__, __sub__, __truediv__</section>
            <p>Основным арифметическим операциям тоже соответствуют магические методы.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_10_1.png' %}" alt="oop_ls_10_1"
                 class="python_img i_27">
            <p>Метод __add__ для сложения.
            <br>Метод __mul__ для умножения.
            <br>Метод __sub__ для вычитания.
            <br>Метод __truediv__ для деления.
            <br>В каждом методе будем проверять является ли переменная 'other' целым или
                вещественным числом для арифметических операций с числами. А вторя проверка нужна для совершения
                арифметических операций над экземплярами. Реализовав эти четыре метода мы теперь
                можем совершать все четыре операции над экземплярами класса Group. При чем порядок записи экземпляров не важен.</p>
            <section class="little_title">Методы сравнения</section>
            <p>Просто так сравнивать между собой экземпляры тоже не выйдет.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_11_1.png' %}" alt="oop_ls_11_1"
                 class="python_img i_28">
            <p>Метод __eq__ для оператора ==.
            <br>Метод __ne__ для оператора !=.
            <br>Метод __lt__ для оператора &lt;.
            <br>Метод __gt__ для оператора &gt;
            <br>Метод __le__ для оператора &lt;=.
            <br>Метод __ge__ для оператора &gt;=.
            <br>Возвращают операторы сравнения True или False. Возможно вы обратили внимание, что в классе
                не реализован метод __ne__, __gt__ и __ge__, но тем не менее операции !=, >, и >= возвращают верный результат. Дело в том,
                что python понимает каким методом воспользоваться, так например, если метод __ne__ не реализован python попробует
                поискать метод __eq__ и если найдет его, то проведет инверсную проверку
                относительно сравнения. Таким образом достаточно
                в программе реализовать три оператора сравнения и их инверсные пары также станут доступны для использования.</p>
            <section class="little_title">__hash__</section>
            <p>Мы уже касались понятия хэш, когда говорили о словарях. Если вспомнить, словари в своей реализации
                используют хэш-таблицы, поэтому словари работают очень быстро. Функция hash() вычисляет хэш объекта,
                но только неизменяемого объекта. И как мы помним в качестве ключа словаря мы
                можем использовать только неизменяемые объекты.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_12_1.png' %}" alt="oop_ls_12_1"
                 class="python_img i_29">
            <p>Хэш значение для одного и того же неизменяемого объекта всегда равно. Откуда можно сделать вывод, если объекты равны, то и их хэш значения равны.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_12_2.png' %}" alt="oop_ls_12_2"
                 class="python_img i_30">
            <p>Создадим два одинаковых экземпляра одного класса и сравним их. Получим достаточно ожидаемый результат - False.
                Дело в том, что таким сравнением мы ссылки на ячейку памяти выделенную под
                конкретный экземпляр и они конечно разные.
                Для сравнения содержимого атрибута требуется определить уже знакомый метод __eq__. Но сначала посмотрим на хэш этих экземпляров.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_12_3.png' %}" alt="oop_ls_12_3"
                 class="python_img i_31">
            <p>Хэши вычисляются и хэши разные. Это говорит нам еще и том, что экземпляр класса считается неизменяемым объектом.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_12_4.png' %}" alt="oop_ls_12_4"
                 class="python_img i_32">
            <p>После реализации __eq__ экземпляры становятся равны, а вот вычисление хэша уже
                становится невозможным. Мы получаем ошибку, говорящую, что экземпляр класса
                нехэшируемый тип данных. Тут нам и пригодится метод __hash__.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_12_5.png' %}" alt="oop_ls_12_5"
                 class="python_img i_33">
            <p>Метод __hash__ позволяет вычислять хэш экземпляра класса. Значения хэша
                целых чисел равны этому же числу, поэтому для наглядности я создал еще один класс с таким же
                поведением, но который принимает кортеж из двух чисел. И как видно помимо того что хэш вычисляется, так теперь это значение еще и одинаковое в случае равенства экземпляров.</p>
            <section class="little_title">__bool__</section>
            <p>Как мы помним любой тип данных в python является объектом, а любой объект можно отнести к одному из
                логических типов - True либо False. Любой значимый объект, будь то не пустой
                список, не пустой словарь или, например, не число ноль относятся к логическому типу True, остальные к типу False.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_13_1.png' %}" alt="oop_ls_13_1"
                 class="python_img i_34">
            <p>Применение функции bool() к любому экземпляру вернет True. Даже если передать в
                качестве аргументов нули. Дело в том, что пока в классе явно не определено поведение метода __bool__, то для отнесения
                объекта к логическому типу используется метод __len__, этот метод возвращает
                True, если длина объекта больше нуля.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_13_2.png' %}" alt="oop_ls_13_2"
                 class="python_img i_35">
            <p>Определим метод __bool__, в котором будем проверять является ли значение нулем и в случае хотя бы одного нуля возвращать False.</p>
            <section class="little_title">__call__</section>
            <p>Метод __call__ вызывается при вызове класса. Например, когда мы создаем экземпляр
                класса таким образом: название_экземпляра_класса = название_класса(). Именно
                круглые скобки в конце названия класса говорят о его выводе и именно в этот момент
                срабатывает метод __call__. И грубо говоря внутри метода __call__ вызывается метод __new__ и метод __init__. Но вот вызвать экземпляр класса через круглые скобки не выйдет. Тут нам и пригодится метод __call__.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_14_1.png' %}" alt="oop_ls_14_1"
                 class="python_img i_36">
            <p>Создадим класс Callable и будем внутри создавать экземпляры, у которых будет название и
                в методе __call__ будем считать количество вызовов каждого экземпляра. При чем работать эти счетчики будут абсолютно независимо. Принимает метод __call__ произвольное количество символов.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_14_2.png' %}" alt="oop_ls_14_2"
                 class="python_img i_37">
            <p>Зачем это может пригодиться? Раз метод __call__ вызывается сразу при вызове экземпляра класса,
                то мы можем описать внутри него какое-то поведение применимое к каждому вызову экземпляра. Например, пусть каждый раз к имени экземпляра применяется метод title().</p>
            <section class="little_title">__setattr__, __getattribute__, __getattr__, __delattr__ </section>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_15_2.png' %}" alt="oop_ls_15_2"
                 class="python_img i_38">
            <p>Метод __setattr__ вызывается, когда мы устанавливаем новое значение для какого-нибудь атрибута.
            <br>Метод __getattribute__ вызывается, когда мы обращаемся к какому-нибудь атрибуту.
            <br>Метод __delattr__ вызывается, когда мы удаляем какой-нибудь атрибут.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_15_1.png' %}" alt="oop_ls_15_1"
                 class="python_img i_39">
            <p>Метод __getattr__ на первый взгляд работает точно так же как и __getattribute__, за
                одним исключением
                __getattribute__ срабатывает при любом обращении к любому атрибуту любого экземпляра, в то время как __getattr__
                срабатывает только при обращении к несуществующему атрибуту. В случае обращения к существующему атрибуту мы увидим
                просто значение этого атрибута. Но ведь атрибут 'w' существует, так почему же мы не видим 400? На самом деле в данном примере
                атрибут 'w' не существует, в этом можно убедиться применив к этому экземпляру
                метод __dict__.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_15_3.png' %}" alt="oop_ls_15_3"
                 class="python_img i_40">
            <p>Почему словарь пустой? Потому что __setattr__ ничего не возвращает. Поведение __setattr__ в данном примере описано не совсем правильно.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_15_4.png' %}" alt="oop_ls_15_4"
                 class="python_img i_41">
            <p>Для корректной работы этого метода нужно обращение к классу object, от которого наследуются все
                классы python. Теперь __setattr__ работает корректно и атрибуты теперь действительно присвоены экземпляру.
                И, следовательно, метод __getattr__ теперь тоже работает корректно. С классом
                object и его назначением мы подробнее познакомимся, когда будем говорить о наследовании.</p>
            <section class="little_title">__getitem__, __setitem__, __delitem__</section>
            <p>В качестве атрибута мы можем передать коллекцию, к элементам которой можно обращаться по индексу и так же через индекс изменять их.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_16_1.png' %}" alt="oop_ls_16_1"
                 class="python_img i_42">
            <p>Пусть класс Languages принимает список языков программирования и если мы захотим обратиться по индексу к элементу этого списка, то получим ошибку.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_16_2.png' %}" alt="oop_ls_16_2"
                 class="python_img i_43">
            <p>Методы __getitem__, __setitem__ и __delitem__ добавят это поведение в наш класс, добавят обращение по индексу, изменение по индексу и удаление по индексу соответственно.</p>
            <section class="little_title">__iter__, __next__</section>
            <p>Говоря о списках возникает вопрос, можно ли по этому списку пройтись в цикле for. Ну раз существуют методы __iter__ и __next__, то очевидно,
                что без реализации этих методов попытка применить к списку цикл for вернет ошибку.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_17_1.png' %}" alt="oop_ls_17_1"
                 class="python_img i_44">
            <p>Добавим методы __iter__ и  __next__.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_17_2.png' %}" alt="oop_ls_17_2"
                 class="python_img i_45">
            <p>Добавим в наш класс метод __iter__, внутри которого сделаем список итератором. Теперь применение к нему цикла for вернет поочередно каждый элемент списка.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_17_3.png' %}" alt="oop_ls_17_3"
                 class="python_img i_46">
            <p>А вот так можно реализовать то же самое поведение, но уже через метод __next__,
                правда при такой реализации мы упираемся в длину списка, и если в данном примере еще раз вызвать print(ex_l.__next__()), то мы получим ошибку,
                говорящую, что итератор закончился. И на самом деле эту ошибку можно достаточно
                просто обработать, но мы этого пока не умеем.</p>
            <section class="little_title">__pos__, __neg__, __invert__</section>
            <p>Унарные, то есть применяемые к одному операнду. Так например унарный минус изменит положительно значение на отрицательное, т.е. подставит перед ним минус.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_18_1.png' %}" alt="oop_ls_18_1"
                 class="python_img i_47">
            <p>Унарные операции реализуются просто подставлением необходимого знака перед числом.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_18_2.png' %}" alt="oop_ls_18_2"
                 class="python_img i_48">
            <p>Метод __pos__ - унарный плюс.
            <br>Метод __neg__ - унарный минус.
            <br>Унарный плюс примененный к отрицательному числу все-равно вернет отрицательное
                число, потому что минус
                'сильнее' плюса. Минус на плюс дает минус. А вот применение унарного минуса к отрицательному числу вернет положительное число, ведь минус на минус дает плюс.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_18_3.png' %}" alt="oop_ls_18_3"
                 class="python_img i_49">
            <p>Множественно присвоение в классах можно реализовать, например, с помощью метода __invert__.</p>
            <section class="little_title">__round__, __floor__, __ceil__, __trunc__</section>
            <p>Округление в python необязательно реализовывать с помощью магических методов.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_19_1.png' %}" alt="oop_ls_19_1"
                 class="python_img i_50">
            <p>Методы __round__, __floor__, __ceil__ и __trunc__ - это 'подкапотная' реализация
                тех методов для округления, которыми мы пользуемся.</p>
            <section class="little_title">Оставшиеся методы арифметических операций</section>
            <p>Осталось еще несколько арифметических операций, которые мы не разобрали.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_20_1.png' %}" alt="oop_ls_20_1"
                 class="python_img i_51">
            <p>Речь идет о целочисленном делении, остатке от деления и возведении в степень.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_20_2.png' %}" alt="oop_ls_20_2"
                 class="python_img i_52">
            <p>Метод __floordiv__ для целочисленного деления.
            <br>Метод __mod__ для остатка от деления.
            <br>Метод __pow__ для возведения в степень, по умолчанию имеет третий необязательный
                аргумент.</p>
            <section class="little_title">__lshift__, __rshift__</section>
            <p>Функция shift() в python работает в сторону увеличения и уменьшения, используются для этого lshift() и rshift() соответственно. Что делает эта функция лучше увидеть на примере.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_21_1.png' %}" alt="oop_ls_21_1"
                 class="python_img i_53">
            <p>Метод __lshift__ образует последовательность (x) - ((x) * 2) - (((x) * 2) * 2) -  ((((x) * 2) * 2) * 2) и так далее.
            <br>Метод __rshift__ образует обратную последовательность, причем округление деления происходит в меньшую сторону.
            <br>Такие операции называют бинарными сдвигами. Поскольку сначала происходит
                преобразование цифры к ее бинарному эквиваленту, сдвигает этот бинарный
                эквивалент на указанное количество знаков, а затем преобразует получившееся
                значение обратно к числовому и возвращает его в виде ответа. Так, например,
                бинарный \эквивалент числа 20 это 10100 применяем к этому числу оператор &lt;&lt; тем самым смещаем число на один
                знак влево и получаем 101000, переводим 101000 обратно к десятичной системе
                счисления и получаем 40.</p>
            <section class="little_title">Бинарное И, ИЛИ, ИЛИ НЕТ</section>
            <p>Раз уж коснулись бинарных сдвигов, то следует упомянуть еще о трех бинарных
                операциях.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_22_1.png' %}" alt="oop_ls_22_1"
                 class="python_img i_54">
            <p>Метод __and__ отвечает за бинарное И.
            <br>Метод __or__ отвечает за бинарное ИЛИ.
            <br>Метод __xor__ отвечает за бинарное ИЛИ НЕТ.
            <br>Принцип работы такой же, переводим число из десятичной системы в двоичную и проводим над ним соответствующую операцию.
            <br>Так, например, 13 в двоичной системе счисления это 1101, а 10 - 1010. Бинарное И сложит эти числа, получив тем самым 1111, что в переводе в двоичную систему равняется 15.</p>
            <section class="little_title">Отраженные операторы. Составное присваивание. Остальные
                магические методы</section>
            <p>У перечисленным выше бинарных и арифметических операциях есть отраженные операторы. В начале каждого
                из них можно вначале написать букву r, так например в методе __add__(self, other) мы в качестве первого операнда
                выбираем self, а в качестве второго other, в случае __radd__ все происходит ровно наоборот. Применение этим методам найти можно редко.</p>
            <p>Так же ко всем этим операторам можно добавить вначале букву i. Эта буква отвечает за составное присваивание так часто
                используемое в python. Так, например, тот же метод __add__(self, other) складывает переменные классическим методом, то есть self + other,
                и результат в таком случае возвращается новым значением и никакая из переменных
                не изменяется, а в случае метода __iadd__ сложение происходит присваиванием, а именно self += other, что можно представить как self = self + other.</p>
            <p>Мы разобрали еще не все магические методы, остались методы преобразования типов, например, метод __int__ для
                преобразования значения к целочисленному значению, думаю с ними совсем все очевидно, если будет нужда в этих методах
                в каком-нибудь примере в будущем мы обязательно прибегнем к ним и посмотрим на их
                работу. <br>Методы __enter__ и __exit__ - методы менеджера контекста, а именно with open() as,
                думаю еще будет момент для рассмотрения их работы, но если говорить об этих методах сейчас метод __enter__
                срабатывает при запуске работы менеджера контекста with, а __exit__ отрабатывает когда все необходимые операции над файлом уже
                выполнены и он готов к закрытию, или выполнении функции close(). <br>Методы __copy__ и __deepcopy__ используются для копирования классов,
                с той разницей, что __copy__ копирует класс, но изменения скопированного класса влияют на изменения оригинального, а в случае __deepcopy__ не влияют.
                <br> Встроенные функции isinstance() и issubclass(), с которой мы еще не знакомы, тоже имеют свои эквиваленты среди
                магических методов __instancecheck__ и __subclasscheck__ соответственно. <br>И
                последняя группа магических методов, это магические методы для сериализации,
                этой темы мы коснемся много позже.</p>
            <section class="little_title">Дескрипторы</section>
            <p>В некоторых магических методах происходило дублирование кода, например, в тех
                местах, где мы делали проверку принадлежности переменной other к типу класса. Дублирование
                функционально одинакового кода, но для разных переменных, выглядит неправильно,
                такое написание противоречит правилу dry(don't repeat yourself). Дескрипторы помогают решить проблему этого нагромождения и описать универсальный интерфейс для функционально одинакового кода.</p>
            <p>Проблему дублирования фрагмента кода с проверкой на принадлежность переменной
                other к классу можно решить и без дескрипторов. Например, вспомним пример из раздела __add__,
                __mul__, __sub__, __truediv__, одинаковая проверка дублируется 4 раза, посмотрим как можно это изменить.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_23_1.png' %}" alt="oop_ls_23_1"
                 class="python_img i_55">
            <p>Например, можно эту проверку снести в обычный метод класса, где будем совершать проверку other на
                принадлежность ее к экземпляру класса. И перед каждой операцией просто совершать эту проверку. Правда работать
                такая проверка будет работать корректно, если применить инструкцию raise, а не
                return, но с raise мы по-прежнему не знакомы, такая реализация использована просто для наглядности.
                Можно и не использовать метод класса, но тогда pycharm возмутится и скажет, что нужен либо метод класса,
                либо статический метод, один из этих вариантов нужно использовать поскольку с помощью таких методов можно обращаться к такому методу не через экземпляр класса, а напрямую.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_23_2.png' %}" alt="oop_ls_23_2"
                 class="python_img i_56">
            <p>Оставим эту проверку, только проверять будем теперь не на принадлежность
                экземпляру класса, а на принадлежность к целочисленному или вещественному типу
                данных, но при этом изменим функциональность самого класса.
                Пусть класс Group принимает теперь два значения, и мы хотим просто обращаться к
                ним, и изменять их. Property в этом поможет, тут нет ничего нового мы уже это
                умеем. Но тут сразу в глаза
                бросается все то же повторение кода, а это класс, у которого всего два атрибута, а что если бы их было больше.
                Конечно, в python есть решение для данной ситуации. Сама идея дескрипторов заключается в создании стороннего класса,
                внутри которого весь этот функционально одинаковый код будет приведен к единому интерфейсу. Реализуем такой класс.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_23_3.png' %}" alt="oop_ls_23_3"
                 class="python_img i_57">
            <p>Начиная с версии python 3.6 у нас появился магический метод __set_name__, внутри которого мы присваиваем
                локальные имена атрибутов экземпляров класса и инициализируем локальную
                переменную self.name. self в этом случае это ссылка на создаваемый внутри класса
                Group экземпляр, owner ссылка на сам этот класс Group, а name это имя переменной, которой присвоен данный экземпляр, в нашем случае
                такими переменными являются count_1 и count_2. Метод __set_name__ класса Descriptor срабатывает сразу при
                создании экземпляров count_1 и count_2, следующим шагом происходит инициализация методом __init__ уже внутри
                класса Group и во время присвоения значений экземпляра класса Group вызывается метод __set__ непосредственно класса
                Descriptor. self в этом случае этот так же ссылка на соответствующий экземпляр класса Descriptor, instance это ссылка на соответствующий
                экземпляр класса Group, а value соответствующее значение экземпляра класса Group. Как мы знаем словарь __dict__ хранит информацию о
                локальных свойствах экземпляра класса, поэтому мы обратимся к этому словарю через переменную instance и для значения self.name, внутри
                которого у нас хранится имя переменной, присвоим новое значение value. Поскольку переменная name хранит имя, в нашем случае она хранит
                имена count_1 и count_2, то новое значение value будет присвоено не имени name, а
                имени присвоенному переменной name, именно поэтому вызов метода __dict__ возвращает не
                {'name': 10, 'name': 20}, а {'count_1': 10, 'count_2': 20}. Ну и если мы хотим считать значение
                какой-то конкретной переменной какого-то экземпляра, то будет использоваться метод __get__ класса Descriptor,
                где self это по-прежнему ссылка на экземпляр класса Descriptor, instance ссылка
                на экземпляр класса Group, а owner ссылка на сам класс Group. И обращаясь к необходимому имени через словарь __dict__ мы просто возвращаем значение этого имени.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_23_4.png' %}" alt="oop_ls_23_4"
                 class="python_img i_58">
            <p>И теперь реализация такого поведения для класса принимающего 5 параметров получилась гораздо компактнее,
                чем получилась бы без использования дескрипторов. Также реализуем метод __delete__, теперь
                взаимодействие с экземплярами классов и их атрибутами выглядит полноценно. И заменим return на raise, для корректной отработки обработки неверно переданных данных.</p>
            <section class="little_title">Наследование</section>
            <p>Концепция наследования подразумевает наследование атрибутов и методов родительского класса классом потомком. Сымитируем проблему.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_24_1.png' %}" alt="oop_ls_24_1"
                 class="python_img i_59">
            <p>Допустим мы собираем информацию о стационарных компьютерах и ноутбуках, но информацию об этих
                устройствах мы собираем одинаковую. Интуитивно напрашивается вынесение
                дублирующегося кода за два этих класса и дальнейшее объединение этого кода.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_24_2.png' %}" alt="oop_ls_24_2"
                 class="python_img i_60">
            <p>Создадим родительский класс PC, для того, чтобы наследоваться от какого-нибудь
                класса, нужно у дочернего класса открыть скобки после названия и написать туда
                название родительского класса. Обратите внимание создание экземпляров по прежнему
                происходит через классы Computer и Laptop, а не через класс PC, конечно, это нужно для того,
                чтобы параметр self понимал на какой класс ссылаться и уникальными свойствами какого класса в последствии пользоваться.</p>
            <section class="little_title">super()</section>
            <p>А теперь представим, что у ноутбуков и стационарных компьютеров будут какие-то уникальные свойства, например цена и время эксплуатации соответственно.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_25_1.png' %}" alt="oop_ls_25_1"
                 class="python_img i_61">
            <p>Для добавления новых атрибутов их конечно нужно снова проинициализировать, но
                тогда возникает проблема, нужно снова инициализировать все атрибуты родительского класса в
                дочерних, и в таком случае дублирование появляется снова. Для решения данной проблемы существует
                функция super(), которая как раз существует для наследования проинициализированных в родительском классе
                атрибутов. Внутрь функции super() не требуется передавать параметр self, функция super() сама находит и
                использует ссылку на родительский класс. Функцию super() всегда рекомендуется вызывать вначале.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_25_2.png' %}" alt="oop_ls_25_2"
                 class="python_img i_62">
            <p>Через super() можно обращаться не только к методу __init__, но и к любому другому методу родительского класса.</p>
            <section class="little_title">Наследование от object. Использование метода __new__</section>
            <p>Я упоминал, что в python по умолчанию происходит наследование от класса object. Это базовый класс,
                который содержит некоторый набор базовых методов. Обеспечивание классов базовым набором методов и
                является причиной такой реализации, и начиная с версии python 3 явное указание наследования от класса object не
                требуется. Теперь можно более подробно обсудить как работает метод __new__.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_26_1.png' %}" alt="oop_ls_26_1"
                 class="python_img i_63">
            <p>Рассмотрим скриншот. Во-первых, то о чем я говорил, наследование от object явно
                прописывать не нужно, но это подразумевается. Функция issubclass() помогает в этом убедится,
                первым параметром в эту функцию передается дочерний класс, а вторым родительский, и если
                наследование действительно есть функция возвратит True, в противном случае False, работает
                эта функция только с классами, а не с их экземплярами.
            <br>Теперь что касается метода __new__. Как мы помним метод __new__ срабатывает до
                инициализации экземпляра в методе __init__, но как мы видим в данном случае метод __new__ вызвался,
                а вот инициализация не произошла, экземпляра класса создан не был. Почему так произошло? Потому что метод __new__ должен возвращать адрес созданного экземпляра.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_26_2.png' %}" alt="oop_ls_26_2"
                 class="python_img i_64">
            <p>Взять этот адрес мы можем из класса object, обратившись к нему функцией super() и
                поскольку метод __new__ относится к набору базовых методов, то и у базового
                класса object он тоже есть, и этот метод как раз будет хранить адрес каждого снова создаваемого экземпляра
                класса. Но зачем это вообще может пригодиться, ведь метод __new__ срабатывает автоматически при создании экземпляра,
                метода __init__ достаточно для корректной работы с экземплярами классов. Действительно этот так, но у метода __new__ есть
                одно применение, благодаря методу __new__ мы можем контролировать возможное
                максимальное количество создаваемых экземпляров,
                а также задавать условие по которому будет решаться создавать этот экземпляр или нет.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_26_3.png' %}" alt="oop_ls_26_3"
                 class="python_img i_65">
            <p>например, вот так можно проконтролировать должен ли создаваться класс или нет.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_26_4.png' %}" alt="oop_ls_26_4"
                 class="python_img i_66">
            <p>А вот так реализуется паттерн 'singleton', этот паттерн позволяет создавать только один экземпляр класса,
                каждый новый экземпляр создаваем после будет помещаться в ту же ячейку памяти, в
                которой находился прошлый созданный экземпляр этого класса. Как это работает? Мы
                создаем приватную переменную, которую принято называть instance, изначально эта переменная ровна None.
                Далее мы делаем проверку, если instance равен None, мы помещаем в нее адрес
                создаваемого экземпляра, а если instance уэе содержит какой-то мы возвращаем его.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_26_5.png' %}" alt="oop_ls_26_5"
                 class="python_img i_67">
            <p>Не стоит забывать и том, что атрибуты последнего созданного экземпляра будут являться единственными существующими атрибутами,
                это, конечно, логично, но эта наглядность помогает окончательно разобраться как
                этот паттерн работает.</p>
            <section class="little_title">Множественное наследование</section>
            <p>Наследоваться можно не от единственного класса, допускается использование нескольких родительских методов.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_27_1.png' %}" alt="oop_ls_27_1"
                 class="python_img i_68">
            <p>Допустим мы ведем учет людей нанимаемых на работу и нам бы хотелось в одной базе данных хранить имя,
                возраст и должность сотрудника, а в другой хранить порядок найма сотрудников в компанию,
                при этом учет хотелось бы вести автоматически. И при необходимости обращаться к атрибутам любой их этих баз.
                Для множественного наследования достаточно перечислить родительские классы через
                запятую, а для связи родительских классов между собой используем функцию super() в первом родительском классе,
                от которого мы наследуемся. Почему функция super() обращается к классу Control, а не к object, мы ведь явно этого нигде не указали.
                Дело в том, что множественное наследование использует специальный алгоритм обхода
                классов, который называется MRO (Method Resolution Order). И в python есть
                одноименный метод __mro__, который выводит последовательность обхода классов.
                Применение метода __mro__ к нашему классу NewWorker показывает, что к object мы обращаемся в последнюю очередь.
                Такие вспомогательные классы при множественном наследовании называются миксины, и миксинов может быть больше чем один.</p>
            <section class="little_title">Коллекция __slots__</section>
            <p>Напоминаю, нам ничего не мешает добавить атрибут в коллекцию __dict__, имени которого там ранее не было.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_28_1.png' %}" alt="oop_ls_28_1"
                 class="python_img i_69">
            <p>Делается это просто написанием имени несуществующего атрибута через точку со значением этого нового атрибута. Коллекция __slots__ ограничивает это поведение.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_28_2.png' %}" alt="oop_ls_28_2"
                 class="python_img i_70">
            <p>В коллекции __slots__ перечисляются доступные имена атрибутов для экземпляров класса. И теперь попытка создания несуществующего атрибута приведет к ошибке.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_28_3.png' %}" alt="oop_ls_28_3"
                 class="python_img i_71">
            <p>А вот когда дело касается наследование создание новых атрибутов допускается. При этом коллекция __dict__ по прежнему не будет содержать имена из коллекции __slots__.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_28_4.png' %}" alt="oop_ls_28_4"
                 class="python_img i_72">
            <p>А если мы все-таки хотим унаследовать коллекцию __slots__ ее следует передать
                явно, при этом атрибуты заново прописывать не требуется.</p>
            <section class="little_title">Полиморфизм</section>
            <p>Еще один важный паттерн ООП - Полиморфизм. Говоря грубо, идея полиморфизма сводится к одинаковому названию логически схожих методов разных классов.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_29_1.png' %}" alt="oop_ls_29_1"
                 class="python_img i_73">
            <p>Например, создадим два класса внутри которых будем переводить валюту в рубли. По
                сути в этой реализации мы видим один и тот же метод, а речь идет только о двух
                валютах, а если таких валют будут десятки, во всех этих разнообразных названиях
                для одинаковых методах можно запутаться, да и не нужно нам это разделение, ведь
                параметр self нам и нужен для того, чтобы понимать, о каком экземпляре идет речь.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_29_2.png' %}" alt="oop_ls_29_2"
                 class="python_img i_74">
            <p>Дадим этим методам одно название это и будет реализацией полиморфизма. Теперь обращаться с
                программой удобнее, более того мы можем поместить все экземпляры в список,
                пройтись по нему в цикле for и поочередно применить одноименный метод к каждому из экземпляров, как вы понимаете при разных названиях этих методов такая реализация была бы невозможна.</p>
            <section class="little_title">Обработка исключений. try / except</section>
            <p>Исключениями в python называют ошибки и их обработка является достаточно важным и полезным навыком в программировании.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_30.png' %}" alt="oop_ls_30_errors"
                 class="python_img i_75">
            <p>На схеме я постарался собрать все существующие на данный момент исключения. Как видно все исключения
                наследуются от BaseException, а далее основная масса ошибок от Exception. Зачем эта информация нужна и в чем заключается идея обработки исключений?</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_30_1.png' %}" alt="oop_ls_30_1"
                 class="python_img i_76">
            <p>Вот один из самых очевидных примеров, складывать строки и целые числа нельзя. Мы получаем исключение
                типа TypeError, говорящую, что действие невозможно. А теперь на следующий пример.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_30_2.png' %}" alt="oop_ls_30_2"
                 class="python_img i_77">
            <p>Первая и третья строка не содержат ошибок и их исполнение выдаст запрашиваемый результат, а вот по центру все еще код написанный с ошибкой.
                Отсюда вытекает причина почему обработка исключений так сильно необходима -
                ошибка прекращает исполнение кода в том месте где она встречается и все строки находящиеся ниже ошибки исполняться не будут.
                Конечно, такого поведения хочется избежать. И на первый взгляд может показаться, пиши код без ошибок и не нужно
                будет ничего обрабатывать, но во-первых, ошибки и программирование друг без друга существовать не могут, любая более менее
                сложная программа это результат сталкивания программиста с большим количеством
                ошибок, а во-вторых, даже полностью правильно написанный код не гарантирует, что ошибки в той или иной ситуации
                при использовании данного кода не возникнут, чуть позже посмотрим на такой
                пример. А пока обработаем нашу ошибку и познакомимся с конструкцией Try/Except.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_30_3.png' %}" alt="oop_ls_30_3"
                 class="python_img i_78">
            <p>Синтаксис этой конструкции такой. В блок try помещается фрагмент кода, в котором
                предполагается возможность возникновения ошибки, а в блоке except происходит
                обработка предполагаемой ошибки и описывается действие, которое нужное сделать,
                если ошибка действительно возникнет. И программа как видно продолжает свое исполнение.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_30_4.png' %}" alt="oop_ls_30_4"
                 class="python_img i_79">
            <p>Возможна обработка сразу нескольких ошибок, например, попробуем взять индекс выходящий за границы индексов списка lst и в except просто пропустим это действие при возникновении ошибки.</p>
            <p>В этих двух примерах мы использовали конкретные типы ошибок, поскольку они нам известны. А что если мы заранее
                не знаем какой тип ошибки может возникнуть в данном фрагменте кода? Для этого я нарисовал тут схему исключений,
                из которой явно видно, что почти все ошибки наследуются от типа Exception. И достаточно частый случай обработки исключений
                это использования в блоке except типа Exception. Это достаточно частая реализация обработки исключений.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_30_5.png' %}" alt="oop_ls_30_5"
                 class="python_img i_80">
            <p>Правда в таком случае pycharm скажет, что использован слишком широкий диапазон исключений, но в данном
                случае pycharm можно не слушать. Рассмотрим повнимательней скриншот. Первой, конструкция, в которой несколько except
                идут после одного try допускаются. Но при этом инструкция сработает для первой найденной ошибки из блока tyr. Как видно
                из примера, поменяв ошибки местами внутри блока try мы видим разные выводы except
                действий. Можно выбирать исключения из еще более широко диапазона, даже не заменой Exception на BaseException,
                а просто написав except с двоеточием, в таком случае абсолютно любая возможная
                ошибка будет отловлена и отработана.</p>
            <p>Но все-таки иногда бывает полезно записывать конкретный тип исключений в except, полезно это может быть в тех ситуациях,
                когда фрагмент внутри блока try может при разном исполнении вызывать разные типы исключений и нам было бы полезно
                понимать какой конкретно тип ошибки случается в данном конкретном исполнении и для каждого такого конкретного типа использовать
                конкретную инструкцию обработки. ДУмаю эта идея всем ясна и понятна.</p>
            <section class="little_title">try / except / finally / else. вложенная обработка исключений. где не получится обойтись без обработки исключений</section>
            <p>На самом деле конструкция try / except может включать в себя еще два необязательных блока - finally и
                else. Блок else отработает в том случае, если в блоке try не будет ни одной ошибки, а блок finally отработает всегда, независимо от того были ли ошибки в блоке tyr или нет.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_30_6.png' %}" alt="oop_ls_30_6"
                 class="python_img i_81">
            <p>Помимо этого можно давать собственное название для ошибки после ключевого слова as. Запись 'except Exception as e'
                возможно встретить достаточно часто. И если нам достаточно увидеть описание ошибки при ее возникновении достаточно распечатать это ключевое слово.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_30_7.png' %}" alt="oop_ls_30_7"
                 class="python_img i_82">
            <p>Конструкция try/except может быть вложенной. При такой реализации будет обработана первая найденная ошибка. Таким
                образом, на скриншоте мы видим, что была обработана ошибка в третьей строке, но
                если закомментировать эту строку или написать ее без ошибок то будет обработана следующая найденная ошибка, в нашем случае IndexError.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_30_8.png' %}" alt="oop_ls_30_8"
                 class="python_img i_83">
            <p>И хотелось бы еще обратить внимание на то, что блок else в данном случае будет исполнена, ведь блок else находится на одном уровне с той конструкцией try/except, в которой ошибки нет.</p>
            <p>Обработка исключений может быть полезна в любой программе, но особенно это может быть полезно в программах где мы запрашиваем какую-то информацию от пользователя.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_30_9.png' %}" alt="oop_ls_30_9"
                 class="python_img i_84">
            <p>Допустим напишем такой простенький калькулятор, который может только умножать и делить числа и делать
                это бесконечное количество раз. И без использования инструкции try/except при делении на ноль программа бы прекратила свое
                выполнение. Контролировать то, что введет пользователь мы, конечно, можем, но не во всех случаях. Вот один из элементарных,
                но достаточно наглядных примеров, когда без try/except программа не станет работать так как мы задумывали.</p>
            <section class="little_title">raise</section>
            <p>Инструкция raise возбуждает исключение.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_31_1.png' %}" alt="oop_ls_31_1"
                 class="python_img i_85">
            <p>Вызывается raise с любым типом исключения, а после типа ошибки в скобках можно написать какой-нибудь текст, который будет выводиться вместе с этим исключением.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_31_2.png' %}" alt="oop_ls_31_2"
                 class="python_img i_86">
            <p>Например, вспомним метод деления и будем проверять является ли переменная other экземпляром класса, и если нет выводить исключение с соответствующим текстом.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_31_3.png' %}" alt="oop_ls_31_3"
                 class="python_img i_87">
            <p>Можно использовать несколько инструкций raise, например на случай, если передать в какой-нибудь
                экземпляр-делитель ноль, ошибка в таком случае будет другого типа, не TypeError, а ZeroDivisionError.
                Допустим в такой ситуации тоже хочется увидеть какой-нибудь заранее заготовленный текст, и вот так
                нехитро это можно реализовать. И как видно из данного примера инструкция raise, как и обычное исключение, останавливает работу программы.</p>
            <section class="little_title">if name == '__main__'</section>
            <p>Хоть эта тема можно сказать и не относится к ООП, но по мне это хорошая тема для завершения всего базового материала по python, под базовым материалом я понимаю базовый синтаксис и ООП.</p>
            <p>Часто можно увидеть скрипты, в конце которых прописана конструкция if name == '__main__', зачем это нужно? Как
                мы знаем по умолчанию каждая программа читается сверху вниз, а также во время запуска программы создается словарь с некоторым набором служебных переменных.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_32_1.png' %}" alt="oop_ls_32_1"
                 class="python_img i_88">
            <p>Список этих служебных переменных можно увидеть через функцию global(). Напишем простенькую программу
                для преобразования метров в разные меры длины, среди служебных переменных помимо прочего мы видим наши функции и
                глобальные переменные, а также переменную '__name__' со значением __main__. Точкой входа в программу на данный момент
                является первая строка, то есть создание переменной dm. Конструкция if name == '__main__' нужна для изменения этой самой точки входа. Для чего это нужно.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_32_2.png' %}" alt="oop_ls_32_2"
                 class="python_img i_89">
            <p>Нужно это тогда, когда мы хотим использовать наш скрипт не только как самостоятельную программу для самостоятельного
                пользования, а когда мы хотим предоставлять какие-то объекты из нашей программы
                для импорта в другие программы. В программу lesson_30_1 импортировано все
                содержимое программы lesson_30 и при простом запуске программы lesson_30_1 мы видим
                все функции print() программы lesson_30. Конечно,
                такого поведения нам бы хотелось избежать. Помимо этого, как видно из результата
                работы программы lesson_30_1 переменная
                __name__ импортированная из программы lesson_30 получает значение равное имени программы, а именно lesson_30, но при прямом
                вызове содержимого переменной __name__ мы видим имя __main__. Таким образом через имя переменной __name__ можно увидеть, какая
                программа является главной, а какая пользуется возможностями этой программы.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_32_3.png' %}" alt="oop_ls_32_3"
                 class="python_img i_90">
            <p>Часто исполнение программы помещают в функцию main(), а далее задают новую точку
                входа в программу конструкцией if name == '__main__' и первым делом выполняют функцию main().
                Теперь импорт всего содержимого и исполнение этой программы не выведет исполнение функций print() главного скрипта.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_32_4.png' %}" alt="oop_ls_32_4"
                 class="python_img i_91">
            <p>Таким образом, мы получили грамотно написанный скрипт, необходимыми функциями которого можно
                пользоваться в сторонних программах без исполнения лишних функций.</p>
            <img src="{% static 'alls_articles/articles/oop/pictures/oop_ls_32_5.png' %}" alt="oop_ls_32_5"
                 class="python_img i_92">
            <p>Так же как и при импорте через оператор звездочка. При исполнении программы мы видим исполнение только
                одной единственной необходимой функции, без выполнения всех функций print().</p>
            <p>Пишите код грамотно, это гораздо приятнее.</p>
        </div>
    </div>
{% endblock %}