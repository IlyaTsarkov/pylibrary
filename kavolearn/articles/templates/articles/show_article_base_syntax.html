{% extends 'articles/base.html' %}

{% block title %}Базовый синтаксис{% endblock %}

{% load static %}

{% block article_content %}
    <div class="container">
        <div class="h2_name">
            <p id="Python">Python</p>
        </div>
        <div class="red">
            <p>В этом обучающем материале будут скриншоты кода и результата его исполнения.
                Это сделано для того, чтобы нельзя было скопировать код, а приходилось писать его вручную. Думаю с аксиомой 'пока ты не пишешь - ты не учишься' никто спорить не будет.
                Для написания кода будет использоваться интегрированная среда разработки
                <a href="https://www.jetbrains.com/pycharm/" class="links" target="_blink">PyCharm</a>.
                Используйте тот редактор, к которому привыкли, это не принципиально. Операционная система - Linux, команды,
                исполняемые в командной строке, тоже будут для Linux. Рекомендую, если вы решили заниматься программированием,
                начать использовать Linux как можно раньше, установка его рядом с Windows или как
                единственную систему на вашем устройстве займет пару часов, не затягивайте с этим. Весь код можно найти у меня в github.</p>
        </div>
        <div class="classic_text">
            <h3 class="h3_name">Введение</h3>
            <p>На начало 2022 года Python является самым популярным языком программирования по
                версии <a href="https://tiobe.com/tiobe-index/" class="links" target="_blank">TIOBE</a>. Python
                понятен, прост в понимании, универсален. Как первый язык программирования для изучения Python отличный вариант.</p>
            <section class="little_title">Установка Python</section>
            <section class="little_title">Редактор кода</section>
        </div>
        <div class="classic_text">
            <h3 class="h3_name">Базовый синтаксис</h3>
            <section class="little_title">Типы данных</section>
            <p>Для написания программ используются типы данных.</p>
            <table class="table">
                <thead class="table-light">
                    <tr><th>Название</th><th>Тип</th><th>Пример</th></tr>
                </thead>
                <tbody>
                    <tr><td>Целочисленный тип (integer)</td><td>int</td><td>1, 2, 3, 15 ...</td></tr>
                    <tr><td>Вещественный тип (floating point)</td><td>float</td><td>1.5, 2.3, 0.3, 15.0 ...</td></tr>
                    <tr><td>Строковый тип (string)</td><td>str</td><td>"hello", "a", "100" ...</td></tr>
                    <tr><td>Списки (list)</td><td>list</td><td>[1, 2, "hello"], [3.5, "400"], [200, 300, 8] ...</td></tr>
                    <tr><td>Словари (dictionary)</td><td>dict</td><td>{"key": "value"}, {"phone":
                        "33333", "name":"jora", "language":"python"} ...</td></tr>
                    <tr><td>Кортежи (tuple)</td><td>tuple</td><td>(1, 3, "abc"), (100.25, "200", 5), ("a", "b", "c") ...</td></tr>
                    <tr><td>Множества (set)</td><td>set</td><td>{1, 2, 3}, {"a", 20.5, "hello"},
                        {2.0, "cba", 15} ...</td></tr>
                    <tr><td>Булевы значения (boolean)</td><td>bool</td><td>True, False</td></tr>
                </tbody>
            </table>
            <p>Конечно со временем мы познакомимся со всеми, но для начала познакомимся с первыми тремя.
                С самими типами вопросов не возникает, целочисленный тип - целые числа, вещественный тип -
                дробные числа, строки - последовательности символов. Но как представить эти типы данных внутри языка
                программирования, конечно, при помощи переменных. Для того чтобы создать
                переменную в Python достаточно дать ей имя и через знак равно написать ее значение.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_1_1.png' %}" alt="lesson_1_1"
                 class="python_img i_1">
            <p>Сразу посмотрим на примере, создадим переменную 'а' со значением 5 - целочисленный
                тип, переменную float_a со значением 5.0 - вещественный тип, обратите внимание .0 после цифры
                тоже делает значение вещественным и переменную 'name' со значением 'jora', тут
                хочу обратить ваше внимание на то, что разницы между двойными - " " и одинарными
                - ' ' кавычками нету. Далее я написал пару примеров с этими переменными, как
                думаете какие значения примут переменные b, c, d и names? Для того чтобы понять,
                как реализуются простые математические вычисления в python, обратимся к консоли.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_1_2.png' %}" alt="lesson_1_2"
                 class="python_img i_2">
            <p>Числа можно складывать, вычитать, умножать и делить, все как в обычной
                математике. Ничего необычного, кроме одного момента. Деление всегда возвращает
                вещественный тип. Также если в выражении есть хоть одно вещественное значение,
                независимо от типа операции результат ее исполнения всегда будет вещественным.
                Помимо классических математических операций есть еще несколько.</p>
            <table class="table">
                <thead class="table-light">
                    <tr><th>Символ</th><th>Математическое действие</th></tr>
                </thead>
                <tbody>
                    <tr><td>+</td><td>Сложение</td></tr>
                    <tr><td>-</td><td>Вычитание</td></tr>
                    <tr><td>*</td><td>Умножение</td></tr>
                    <tr><td>/</td><td>Деление</td></tr>
                    <tr><td>**</td><td>Возведение в степень</td></tr>
                    <tr><td>//</td><td>Целочисленное деление</td></tr>
                    <tr><td>%</td><td>Остаток от деления</td></tr>
                </tbody>
            </table>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_1_2_1.png' %}" alt="lesson_1_2_1"
                 class="python_img i_2_1">
            <p>Целочисленное деление показывает сколько раз делитель помещается в делимом, то есть 15 // 3 = 5 и 17 // 3 = 5,
                потому что в обоих случаях 3 помещается в эти числа 5 раз. Остаток от деления
                показывает, какое число остается
                после совершения деления. Больше математических действий доступно во встроенной
                библиотеке math, но ее мы коснемся позже.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_1_3.png' %}" alt="lesson_1_3"
                 class="python_img i_3">
            <p>Разобравшись с простыми математическими операциями можно посмотреть что же
                получится в примерах выше. Думаю с числами все понятно интуитивно,
                а вот со строками результат неочевиден. Если строки умножать на значение,
                то результатом такой операции будет строка повторяющаяся столько раз, на какое
                значение она была умножена. А как думаете что если ниже добавить такое выражение:<br>
            <code>names_2 = names + name</code><br>
            names_2 будет равняться 'jorajorajora', отсюда сделаем вывод, что строки можно
                умножать и складывать, а вот поделить строку на строку или вычесть строку из строки не выйдет.</p>
            <p>Если вы тоже писали этот код, то возможно вы уже попробовали исполнить его, но
                вместо результата как на скриншоте вы увидели пустой ответ
                и сообщение Process finished with exit code 0, которое свидетельствует о том, что
                программа отработала успешно. Вы ничего не увидели, потому что вы не вывели
                результат на печать. Для того чтобы вывести результат программы,
                существует функция print(), а для того чтобы не вводить значение внутри программы,
                а запросить его у пользователя существует функция input().</p>
            <section class="little_title">Функции print() и input()</section>
            <p>Давайте теперь выведем результат. Для того чтобы в pycharm запустить программу
                можно воспользоваться комбинацией горячих клавиш ctrl + shift + f10, либо нажать
                правой кнопкой мыши по окну программы и нажать на зеленый треугольник с надписью run.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_1_4.png' %}" alt="lesson_1_4"
                 class="python_img i_4">
            <p>Как упоминалось выше функция print() выводит на экран значение, переданное внутрь
                функции print(). Для того чтобы передать внутрь print какую-то переменную используемую в программе,
                достаточно ее написать, кавычки в таком случае не требуются. Для того чтобы
                передать текст, его необходимо
                обернуть в кавычки. Все значения внутри print должны быть перечислены через запятую. print может быть не один,
                если в программе 2 print, то значение второго будет выведено на новой строке, так же как и следующий print,
                если таковой имеется. Также обратите внимание, что пробелы внутри кавычек это тоже
                символы и они учитываются в выводе.
                Внутри print() можно также выполнять математические операции.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_2_1.png' %}" alt="lesson_2_1"
                 class="python_img i_5">
            <p>Например, это можно сделать так. Комбинирование чисел и переменных также не
                запрещено.</p><p>Теперь давайте из абстрактных примеров перейдем к реальным задачам.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_2_2.png' %}" alt="lesson_2_2"
                 class="python_img i_6">
            <p>Например напишем вот такую программу. Функция input() запрашивает данные у пользователя и
                присваивает их той переменной, внутри которой была вызвана эта функции, а текст
                написанный внутри команды input() будет виден пользователю. Во вкладке с результатом это хорошо
                видно, 'a = ' и 'b = ' - содержимое команд input(), зеленые цифры данные введенные пользователем,
                в данном случае мной. Обратите внимание, по умолчанию любое содержимое переданное
                в функцию input() будет ровняться строковому типу, по этому если мы хотим
                преобразовать значение к другому типу, нужно обернуть input() в функцию соответсвующую
                преобразованию в тот тип данных, который нас интересует, в данном случае обернем
                input() в int() для преобразования полученных данных к
                целочисленному типу данных. С функцией print() мы уже разобрались ранее. Вот так в
                четыре строчки можно посчитать площадь и периметр любых прямоугольников, стороны
                которых являются целыми числами. Если мы захотим считать площадь и периметр прямоугольников с
                дробными сторонами, то просто заменим int() на float(). При чем во float() можно будет передавать
                целочисленное значение, например 5, и функция float() автоматически преобразует цифру 5 к виду 5.0.</p>
            <section class="little_title">Еще пару слов о Print</section>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_2_3.png' %}" alt="lesson_2_3"
                 class="python_img i_7">
            <p>Нам необязательно для переноса строки писать новый print(), для этих целей в Python есть служебный символ
                \n, который равен переносу строки. Правда как можно заметить перед словом 'периметр' появился пробел,
                конечно, хотелось бы, чтобы его не было. Этот пробел появляется из-за скрытого параметра функции print(), который по умолчанию равен пробелу.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_2_4.png' %}" alt="lesson_2_4"
                 class="python_img i_8">
            <p>Параметр 'sep=' поможет нам решить проблему с пробелом, просто заменим его содержимое на пустое
                значение, в python это делается пустыми кавычками. Пробела теперь нет. В параметр
                sep можно передать любую последовательность символов, тогда содержимое print()
                будет разделено содержимым параметра sep (sep от англ. separate - разделять).
                Служебный, или грамотней назвать его экранированный, символ \n не единственный в python.</p>
            <table class="table">
                <thead class="table-light">
                    <tr><th>Экранированная последовательность</th><th>Описание</th></tr>
                </thead>
                <tbody>
                    <tr><td>\n</td><td>Перенос строки</td></tr>
                    <tr><td>\\</td><td>Используется для записи обратного слэша</td></tr>
                    <tr><td>\'</td><td>Используется для записи одинарной кавычки</td></tr>
                    <tr><td>\"</td><td>Используется для записи двойной кавычки</td></tr>
                    <tr><td>\t</td><td>Горизонтальная табуляция</td></tr>
                    <tr><td>\v</td><td>Вертикальная табуляция</td></tr>
                    <tr><td>\r</td><td>Возврат каретки (курсора) в начало строки</td></tr>
                    <tr><td>\b</td><td>Удаление предыдущего символа (аналог клавиши
                        backspace)</td></tr>
                    <tr><td>\f</td><td>Перенос на новую строку, причем отступ новой строки равен длине символов стоящих до \f</td></tr>
                    <tr><td>\0</td><td>Null</td></tr>
                    <tr><td>\ooo</td><td>Восьмеричный код символа</td></tr>
                    <tr><td>\xhh</td><td>Шестнадцатеричный код символа</td></tr>
                    <tr><td>\N{id}</td><td>id Unicode символа</td></tr>
                    <tr><td>\uhhhh</td><td>Шестнадцатибитный код символа Unicode</td></tr>
                    <tr><td>\Uhhhhhhhh</td><td>Тридцатидвухбитный код символа Unicode</td></tr>
                    <tr><td>\a</td><td>Гудок (ни разу не встречал, чтобы его использовали)</td></tr>
                </tbody>
            </table>
            <p>На самом деле, ни разу не встречал я не только символ \a, но и шесть символов,
                стоящих до него. Скорее всего, пользоваться любыми символами, кроме первых четырех, вы будете очень редко, тем не менее знать об их существовании не помешает.</p>
            <p>Последний необязательный параметр функции print(), который хотелось бы упомянуть
                это end.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_2_5.png' %}" alt="lesson_2_5"
                 class="python_img i_9">
            <p>'end=' - необязательный параметр, который по умолчанию равен '\n'. Содержимым,
                которе передано в параметр end, будет заканчиваться содержимое функции print().</p>
            <section class="little_title">Работа со строками</section>
            <p>Давай напишем классическую программу, для обучения работы со строками.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_3_1.png' %}" alt="lesson_3_1"
                 class="python_img i_10">
            <p>f-строка поможет нам в реализации этой задачи. f-строкой вы будете пользоваться очень часто, это полезный,
                простой и удобный инструмент для работы со строками. В f-строку можно поместить
                любые переменные, заключив их в фигурные скобки. Все пробелы и прочее форматирование внутри f-строк сохраняется.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_3_2.png' %}" alt="lesson_3_2"
                 class="python_img i_11">
            <p>Еще один полезный метод для работы со строками - title(). title() преобразует каждый первый символ новой
                последовательности в верхнему регистру. Можно применить его к нужной строке в любом месте кода, как показано на примере.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_3_3.png' %}" alt="lesson_3_3"
                 class="python_img i_12">
            <p>Для смены регистра всех символов существую методы lower() и upper() для преобразования символов в нижний и верхний регистр соответственно.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_3_4.png' %}" alt="lesson_3_4"
                 class="python_img i_13">
            <p>Если требуется удалить лишние пробелы существует метод strip(), который удалит
                пробелы с обеих сторон. Если требуется удалить пробелы только с левой или с правой
                стороны, существуют методы lstrip() и rstrip() соответственно, где l - left, а r - right.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_3_5.png' %}" alt="lesson_3_5"
                 class="python_img i_14">
            <p>Внутри кода можно, и даже нужно, оставлять комментарии. Делается это после символа #. Комментарии никак
                не влияют на работу кода, и они не видны пользователю. Они нужны для других программистов, которые по каким-то причинам будут просматривать ваш код,
                чтобы они могли быстрее разобраться, что и для чего вы написали. Естественно
                комментарии не нужно оставлять ко всему подряд, как я сделал в примере, комментарии оставляются в более
                сложных программах, в местах где они действительно нужны. Писать уместные, лаконичные и понятные
                комментарии это важный навык в работе программиста. Работа над проектом обычно происходит не в одиночку,
                поэтому опытные программисты обычно ожидают увидеть комментарии в том коде, за который они берутся.</p>
            <section class="little_title">Строки. Срезы. Неизменяемые типы данных</section>
            <p>Типы данных в python можно поделить на изменяемые(mutable) и неизменяемые(immutable). Все три типа данных,
                которые мы с вами разобрали, являются неизменяемыми, так же к неизменяемым типам
                данных относятся кортежи. Как понять, чем отличается неизменяемые и изменяемые типы данных в python.
                Каждая переменная, которую мы объявили внутри программы, занимает определенную ячейку памяти. Эту ячейку можно увидеть, если применить к переменной функцию id().</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_4_1.png' %}" alt="lesson_4_1"
                 class="python_img i_15">
            <p>Так вот, если например мы создадим переменную 'a' со значением 2, а после перезапишем ее значение на 4, прибавив еще 2, то ячейка памяти,
                отведенная для переменной 'a' изменится. Это поведение характерно для неизменяемых типов данных. Изменяемые типы сохраняют ячейку памяти отведенную им, даже после их изменения.</p>
            <p>Числа мы изменяем обычными математическими действиями. А что со строками. Мы уже
                знаем, что строки можно умножить на какое-нибудь целочисленное значение, и результатом такого действия будет
                повторение строки, количество повторений зависит от числа, на которое она была умножена. Строки можно складывать,
                результатом будут склеенные в одну строки, сложение строк в программировании
                называется конкатенация. Строка, как упоминалось ранее это последовательность символов. И в python с этой последовательностью можно взаимодействовать.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_4_2.png' %}" alt="lesson_4_2"
                 class="python_img i_16">
            <p>При помощи квадратных скобок мы можем взять срез символов из строки. Первое
                значение это символ, с которого мы начинаем срез. Через двоеточие значение,
                которым мы заканчиваем срез. Обратите внимание, если последовательность
                заканчивается на цифру например 5, то последним возьмется четвертый символ последовательности, а не пятый.
                Также обращаю ваше внимание, что индексы символов начинаются не с 1, а с 0.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_4_3.png' %}" alt="lesson_4_3"
                 class="python_img i_17">
            <p>Например, вот такие индексы принадлежат символам строки из примера. Пробелы это тоже символы, которым присвоен свой индекс.<br>
                Если в срезе указано только первое значение, то вторым значением будет автоматически считаться значение последнего
                индекса, если не указано первое значение, то срез начнется со значения нулевого индекса. Если указать [::] это будет означать, что следует взять всю последовательность символов.</p>
            <p>В срезе можно указать третье значение. Его значение это шаг, с которым мы
                проходимся по последовательности символов. То есть, если третьим значением
                указано 2, это будет означать, что мы пропускаем каждый второй символ последовательности. На примере хорошо видно как это устроено.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_4_4.png' %}" alt="lesson_4_4"
                 class="python_img i_18">
            <p>Срез можно брать в обратном порядке. Последнему символу присвоен индекс -1. Обратные индексы всегда начинаются с -1, а не с нуля. Например запись [::-1] перевернет строку задом наперед.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_4_5.png' %}" alt="lesson_4_5"
                 class="python_img i_19">
            <p>Срез можно присвоить переменной, а после использовать их. Также можно взять
                конкретный символ, просто указав в квадратных скобках его индекс.</p>
            <section class="little_title">bool. Операторы сравнения</section>
            <p>Логический тип bool может вернуть только одно из двух значений. True - истина,
                False - ложь. Для того чтобы посмотреть, как это работает на практике,
                познакомимся с операторами сравнения.</p>
            <table class="table">
                <thead class="table-light">
                    <tr><th>Символ</th><th>Описание</th></tr>
                </thead>
                <tbody>
                    <tr><td>&lt;</td><td>Меньше</td></tr>
                    <tr><td>&gt;</td><td>Больше</td></tr>
                    <tr><td>&lt;=</td><td>Меньше или равно</td></tr>
                    <tr><td>&gt;=</td><td>Больше или равно</td></tr>
                    <tr><td>==</td><td>Равно</td></tr>
                    <tr><td>!=</td><td>Не равно</td></tr>
                    <tr><td>not</td><td>Логическое НЕ</td></tr>
                    <tr><td>in</td><td>Проверка на вхождение, например, символа в последовательность</td></tr>
                    <tr><td>not in</td><td>Проверка на не вхождение, например, символа в последовательность</td></tr>
                    <tr><td>and</td><td>Логическое И. Через оператор and можно добавлять в конструкции дополнительные условия</td></tr>
                    <tr><td>or</td><td>Логическое ИЛИ. Оператор or, используется там, где требуется соблюдения хотя бы одного условия</td></tr>
                </tbody>
            </table>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_4_6.png' %}" alt="lesson_4_6"
                 class="python_img i_20">
            <p>Тип bool также относится к неизменяемым типам данных.</p>
            <section class="little_title">Остальные операции и методы строк</section>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_5_1.png' %}" alt="lesson_5_1"
                 class="python_img i_21">
            <p>Первое о чем нужно упомянуть - функция len(). len() возвращает количество символов в строке.<br>
                Метод .count() вернет количество вхождений указанного символа в строку. Метод .count()
                можно применить к срезу, для этого срез указывается после необходимого символа через запятую.<br>
                Метод .replace() заменяет символы в сроке. Первое значение - символ, который нужно заменить,
                второе - символ, на который нужно заменить. Если третьим параметров передать
                цифру, то это будет означать сколько из присутствующих в последовательности символов нужно заменить.<br>
                Метод .find() вернет индекс первого найденного символа, переданного в метод .find(). Если
                вторым параметром указать цифру, то это будет означать с какого индекса строки начать поиск.<br>
                Метод .rfind() делает тоже, что и .find() только .rfind() проходит по строке в обратном направлении.
            </p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_5_2.png' %}" alt="lesson_5_2"
                 class="python_img i_22">
            <p>Методы .rjust() и .ljust() увеличивают длину строки до значения, которое указано в этих методах. .rjust() добавляет
                символы слева, .ljust() добавляет символы справа. Если значение не указано, то заполняет пробелами, если указано, то заполняет указанным символом.
            <br>Метод .split() делит строку по указанному символу, по умолчанию разделяет по пробелам.
            <br>Метод .join() обратное действие метода .split(), предварительно превращена в
                список строка, конкатенируется в новую строку по указанному символу.
            </p>
            <p>Для удобства представлю все эти методы таблицей.</p>
            <table class="table">
                <thead class="table-light">
                    <tr><th>Методы и функции строк</th><th>Описание</th></tr>
                </thead>
                <tbody>
                    <tr><td>len()</td><td>Функция, которая возвращает количество символов в строке</td></tr>
                    <tr><td>.title()</td><td>Преобразует каждый первый символ нового слова в строке к верхнему регистру</td></tr>
                    <tr><td>.lower()</td><td>Преобразует все символы в нижний регистр</td></tr>
                    <tr><td>.upper()</td><td>Преобразует все символы в верхний регистр</td></tr>
                    <tr><td>.strip(), .lstrip(), .rstrip()</td><td>Обрезание пробелов по краям строк</td></tr>
                    <tr><td>.count()</td><td>Вернет количество вхождений указанного символа в
                        строку. Можно применить к срезу</td></tr>
                    <tr><td>.replace()</td><td>Заменяет символы в строке</td></tr>
                    <tr><td>.find(), .rfind()</td><td>Вернет индекс первого найденного символа, переданного в метод</td></tr>
                    <tr><td>.rjust(), .ljust()</td><td>Увеличивают длину строки до значения, переданного в эти методы</td></tr>
                    <tr><td>.split()</td><td>Делит строку по указанному символу, по умолчанию разделяет по пробелам</td></tr>
                    <tr><td>.join()</td><td>Конкатенирует список строк по переданному указателю</td></tr>
                </tbody>
            </table>
            <section class="little_title">Списки</section>
            <p>Первый изменяемый тип данных, который мы разберем, - списки. Список - упорядоченная коллекция объектов произвольных типов. Создаются списки внутри квадратных скобок через запятую.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_6_1.png' %}" alt="lesson_6_1"
                 class="python_img i_23">
            <p>Как было сказано выше, тип данных не важен. Со списками можно работать так же, как
                и со строками, то есть обращаться по индексу к элементу списка, первый индекс
                также равен нулю. Также можно брать их срезы, с любым шагом и в любом
                направлении.<br>Функция list() превращает строку в список, как видно на примере.
                Для чисел эта функция не работает.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_6_2.png' %}" alt="lesson_6_2"
                 class="python_img i_24">
            <p>К списку можно применить функцию len(), которая вернет длину списка.
            <br>Функция max() вернет максимально число из списка.
            <br>Функция min() вернет минимальное число из списка.
            <br>Функция sum() вернет сумму чисел списка.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_6_3.png' %}" alt="lesson_6_3"
                 class="python_img i_25">
            <p>Функции max() и min() применимы также к строкам, они возвратят строку максимальной и минимальной длины соответственно. Функция sum() к строкам не применима.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_6_4.png' %}" alt="lesson_6_4"
                 class="python_img i_26">
            <p>Списки можно отсортировать функцией sorted(). Числа сортируются по возрастанию, буквы по алфавитному порядку.
                Обратите внимание функция sorted() не изменяет список, то есть если вывести
                список, к которому была применена функция sorted() после, то список будет представлен в
                первоначальном виде. Необязательный параметр 'reverse=' в значении True развернет сортировку, по умолчанию установлено значение False.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_6_5.png' %}" alt="lesson_6_5"
                 class="python_img i_27">
            <p>Списки, так же как и строки, можно конкатенировать и умножать.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_6_6.png' %}" alt="lesson_6_6"
                 class="python_img i_28">
            <p>Списки могут быть вложенными, для вложенности достаточно открыть новый список
                внутри существующего, как это сделано на примере. На первом уровне вложенности
                один список равен одному элементу. Это видно, если применить функцию len() к
                данному списку. Для того чтобы обратится к элементу вложенного списка, нужно сначала обратиться к индексу данного списка и далее,
                если вложенность продолжается продолжать это действие пока не доберемся до
                нужного элемента. Вложенность списков не ограничена.</p>
            <section class="little_title">Основные методы списков</section>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_7_1.png' %}" alt="lesson_7_1"
                 class="python_img i_29">
            <p>Метод .copy() создаст точную копию списка, работает точно так же, как если бы мы
                взяли полный срез списка записью [:]. Ранее я упоминал о разнице между изменяемыми и неизменяемыми типами данных. Так вот копия списка будет занимать новую ячейку памяти.
            <br>Метод .append() добавит значение в конец списка.
            <br>Метод .clear() очистит список и оставит его пустым.
            <br>Метод .count() вернет количество вхождений элемента в список.
            <br>Метод .index() вернет индекс элемента, возвращает индекс первого соответствия.
            <br>Метод .pop() вырежет последнее значение списка. В метод .pop() можно передать индекс элемента, который нужно вырезать.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_7_2.png' %}" alt="lesson_7_2"
                 class="python_img i_30">
            <p><br>Метод .insert() добавит значение по указанному индексу. Первый параметр -
                индекс, второй - значение.
            <br>Метод .remove() вырежет указанное значение из списка.
            <br>Метод .reverse() перевернет список задом наперед.
            <br>Метод .sort() отсортирует список по возрастанию. Если передать параметр reverse в значении True список отсортируется в обратном порядке.</p>
            <table class="table">
                <thead class="table-light">
                    <tr><th>Методы списков</th><th>Описание</th></tr>
                </thead>
                <tbody>
                    <tr><td>.copy()</td><td>Создает копию списка</td></tr>
                    <tr><td>.append()</td><td>Добавляет элемент в конец списка</td></tr>
                    <tr><td>.clear()</td><td>Очищает список и оставляет его пустым</td></tr>
                    <tr><td>.count()</td><td>Возвращает количество вхождений элемента в список</td></tr>
                    <tr><td>.index()</td><td>Возвращает индекс указанного элемента</td></tr>
                    <tr><td>.pop()</td><td>Вырезает последний элемент списка</td></tr>
                    <tr><td>.insert()</td><td>Добавляет элемент по указанному индексу</td></tr>
                    <tr><td>.remove()</td><td>Вырезает указанный элемент из списка</td></tr>
                    <tr><td>.reverse()</td><td>Переворачивает список задом наперед</td></tr>
                    <tr><td>.sort()</td><td>Сортирует список по возрастанию, параметр reverse по умолчанию в значении False</td></tr>
                </tbody>
            </table>
            <section class="little_title">if/else/elif</section>
            <p>С помощью конструкции if/else/elif можно проверять программу на соответствие каким-либо условиям. Сразу посмотрим на примере.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_8_1.png' %}" alt="lesson_8_1"
                 class="python_img i_31">
            <p>Напишем простую программу, которая будет проверять является ли число четным или нет. Переменная digit
                запрашивает число у пользователя. Далее в условии if мы делаем проверку числа на четность, сделать это
                можно проверкой по остатку от деления. И если условие выполняется, возвратим
                сообщение 'Вы ввели четную цифру', в противном случае выведем 'Вы ввели нечетную цифру'. В else
                всегда попадают любые другие условия, несоответствующие главному if.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_8_2.png' %}" alt="lesson_8_2"
                 class="python_img i_32">
            <p>elif, буквально можно перевести как - иначе если. Внутри elif прописываются дополнительные условия,
                if всегда стоит вначале else всегда стоит в конце, elif, если он нужен, всегда
                стоит между ними. Количество elif не ограничено.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_8_3.png' %}" alt="lesson_8_3"
                 class="python_img i_33">
            <p>Условный оператор может иметь вложенность, причем вложенность неограниченна.
                Условия всегда проверяются сверху вниз, и как только какое-то условие выполняется мы погружаемся
                на более глубокий уровень вложенности, пока не доберемся до условия, которое максимально подходит
                для созданной ситуации. Каждый новый, более глубокий уровень вложенности, должен начинаться с отступа.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_8_4.png' %}" alt="lesson_8_4"
                 class="python_img i_34">
            <p>Существует более лаконичный способ записи условного оператора, он называется - тернарный условный оператор.
                Тернарный условный оператор записывается в сроку, действие выполняемое при
                соблюдении первого условия пишется перед ним, действие выполняемое при нарушении
                условия пишется в конце конструкции, а сами условия по центру конструкции.
                Тернарный условный оператор поддерживает только условия if else, elif использовать внутри тернарного условного оператора не получится.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_8_5.png' %}" alt="lesson_8_5"
                 class="python_img i_35">
            <p>А вот вложенность на тернарный условный оператор распространяется. Работает она
                точно также, сначала проверяем условие первого уровня и если есть углубление, то погружаемся на уровень ниже при соблюдении условия.</p>
            <section class="little_title">Цикл while</section>
            <p>В прошлом разделе мы написали несколько программ, проверяющих число на какое-нибудь
                условие. Но после одной итерации программа останавливалась, и для проверки нового
                числа приходилось ее перезапускать. Циклы помогут нам это изменить.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_9_1.png' %}" alt="lesson_9_1"
                 class="python_img i_36">
            <p>Посмотрим пример. While буквально означает 'пока', т.е 'пока какое-то условие
                соблюдается действие внутри цикла продолжается'. Создадим 2 списка even_list - для четных
                чисел, not_even_list - для нечетных, а также создадим переменную n равную нулю. В условии цикла скажем,
                что он будет повторяться пока n меньше 5 и далее в конце каждого цикла будем
                увеличивать n на 1(запись n += 1 равносильна записи n = n + 1). Внутри цикла каждый раз создаем переменную
                'a', значение которой запрашиваем у пользователя и с помощью остатка от деления проверяем является ли число
                четным или нет, и в зависимости от проверки заносим его в нужный список. После того как
                условие перестало выполняться, цикл заканчивается и программа продолжает
                выполняться. Ниже будем запрашивать у пользователя какой список он хочет увидеть
                и далее с помощью конструкции if/elif/else выведем пользователю тот список,
                который ему нужен. Обратите внимание я применил к этой переменной метод .lower(), чтобы независимо от регистра букв слово воспринималось правильно.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_9_2.png' %}" alt="lesson_9_2"
                 class="python_img i_37">
            <p>У цикла while есть три оператора: break, continue и else. break прерывает цикл
                и полностью останавливает его работу, в данном примере напишем условие - как
                только n станет равное четырем цикл следует прервать, как видно на примере цикл
                отработал четыре раза, а не пять. continue пропустит все действия цикла
                расположенные ниже этого оператора и вернет исполнение программы в начало цикла,
                на примере напишем условие в конце каждой итерации цикла выводить слово 'отработало' и,
                как видно, в том месте где continue выполняется слово 'отработало' не выводится. else, все действия
                принадлежащие этому оператору будут исполнены, когда цикл штатно прервется.
                Почему в данном примере else не сработал? Потому что цикл был прерван
                оператором break и поскольку данный else относится к циклу, а break прерывает
                работу всего цикла, условие не выполнилось. Прерывание по break считается не
                штатным. Если удалить условие break, то фраза 'n больше четырех' вывелась бы на
                экран после пятой итерации.</p>
            <section class="little_title">Функции range() и enumerate()</section>
            <p>While не единственный цикл в python, но перед переходом к следующему следует
                разобрать функцию range.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_10_1.png' %}" alt="lesson_10_1"
                 class="python_img i_38">
            <p>Функция range генерирует арифметическую последовательность. Для преобразования последовательности к
                списку обернем range в функцию list. Если просто распечатать range через print мы увидим
                первую и последнюю точку последовательности, как видно на примере. А еще из этого примера хорошо
                видно, что если в range передать одну цифру, то эта цифра является конечной точкой последовательности
                и если первая точка не задана, то последовательность начнется с нуля. Отсюда становится понятно, что
                если передана первая цифра, то она и будет являться начальной точкой. Третья
                цифра - шаг последовательности. Начальная точка всегда должна быть меньше конечной.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_10_2.png' %}" alt="lesson_10_2"
                 class="python_img i_38.1">
            <p>Функция enumerate() возвратит кортеж. enumerate() принимает два
                значения, первое точка отсчета, второе объект итератор, об этом позже.
                Если передано одно значение, то отсчет по умолчанию начнется с 0.</p>
            <section class="little_title">Цикл for</section>
            <p>Цикл for используется для перебора итерируемых объектов, что такое итерируемые объекты мы разберем подробнее чуть позже.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_11_1.png' %}" alt="lesson_11_1"
                 class="python_img i_39">
            <p>Цикл for последовательно проходит по итерируемому объекту и каждую итерацию переменная,
                переданная в цикл for, поочередно принимает значение итерируемого объекта.
                Создадим список ex_list с помощью функции range и пробежимся по нему в цикле,
                поочередно выводя переменную x, видим каждое значение списка выведенное на новую строку.
                По аналогии пробежимся по этому списку, и каждое значение будем умножать на 2, добавляя
                получившееся значение в новый список new_list. И в последнем цикле for посчитаем
                сумму арифметической прогрессии от 0 до 4. Функция range часто и тесно
                взаимодействует с циклом for. И отсюда можно сделать вывод, что цикл for возвращает итерируемый объект.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_11_2.png' %}" alt="lesson_11_2"
                 class="python_img i_40">
            <p>Цикл for может быть вложенным. На скриншоте представлен частый пример, демонстрирующий работу вложенного цикла.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_11_3.png' %}" alt="lesson_11_3"
                 class="python_img i_41">
            <p>Схематично это можно изобразить так. Мы заходим в цикл внутри переменной i и
                поочередно перебираем для нее все значения переменной j вложенного цикла.
                Повторяем это действие пока остались элементы итерируемого объекта главного
                цикла. Второй print добавлен для лишнего пробела.</p>
            <section class="little_title">Итерируемые объекты</section>
            <p>Можно сказать, итерируемый объект - объект, который способен возвращать по одному
                элементу. Какие типы данных в python являются итерируемыми объектами? Списки,
                строки, словари, кортежи, а также файлы. Ко всем этим типам данных можно применить
                функции iter() и next(). Функция iter() нужна для преобразования типа данных к объекту под
                названием итератор, а уже по итератору мы можем поочередно проходиться функцией next().
                Эти два метода и используются, так сказать, 'под капотом' цикла for.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_12_1.png' %}" alt="lesson_12_1"
                 class="python_img i_42">
            <p>Вот так устроено цикл for для списка числе от 0 до 3. Функция iter()
                превращает список в объект итератор, а функция next() поочередно перебирает
                каждый элемент этого итератора. Как только, с помощью функции next() все элементы
                пройдены, мы получаем ошибку StopIteration, благодаря обработке этой ошибки цикл
                for заканчивается, но об обработке ошибок мы поговорим позже.</p>
            <p>Всегда для освежения информации удобнее возвращаться к структурированной информации, поэтому оберну прошлые 5 тем в таблицу.</p>
            <table class="table">
                <thead class="table-light">
                    <tr><th>Имя</th><th>Описание</th></tr>
                </thead>
                <tbody>
                    <tr><td>if/elif/else</td><td>Условный оператор, с помощью него можно
                        создавать логические ветвления, можно также назвать его - оператор выбора</td></tr>
                    <tr><td>while</td><td>Повторение действия, пока выполняется условие. Для манипуляций с while используются операторы break, continue и else</td></tr>
                    <tr><td>for</td><td>Повторение действия, пока не закончились элементы итератора</td></tr>
                    <tr><td>range()</td><td>Генерирует арифметическую последовательность</td></tr>
                    <tr><td>enumerate()</td><td>Возвращает кортеж вида (start, типа int(), элемент объекта, поддерживающий метод next())</td></tr>
                    <tr><td>iter() и next()</td><td>iter() превратит последовательность в объект итератор, next() поочередно переберет элементы итератора</td></tr>
                </tbody>
            </table>
            <section class="little_title">Словари</section>
            <p>Словари (dict) неотъемлемая часть реализации python. Важно понимать, что в основе
                словарей лежат хэш-таблицы, это означает, что словари работают очень быстро. Идея хэш-таблиц
                заключается в том, что каждому значению присвоен свой ключ, и когда мы хотим
                обратиться к какому-нибудь значению словаря мы делаем это по ключу, а не
                перебираем всю последовательность пока не дойдем до нужного элемента, отсюда и
                очень высокая скорость работы.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_13_1.png' %}" alt="lesson_13_1"
                 class="python_img i_43">
            <p>Словарь можно создать двумя способами, первый и самый часто используемый - фигурные скобки,
                внутри которых через двоеточие помещаются пары ключ:значение. Второй - функция dict().
                Если мы создаем словарь с нуля мы делаем это через фигурные скобки, если хотим
                преобразовать уже существующий тип данных к словарю используем функцию dict().
                Обращаться мы можем только к ключу, для того чтобы это сделать поместим ключ нужного
                значения в квадратные скобки после названия словаря. Для добавления новой пары в словарь
                достаточно написать название словаря, после него в квадратных скобках задать название нового
                ключа и через равно задать значение этого ключа. Значение ключа можно переписать просто задав
                для ключа новое значение. Ключом словаря может являться любой неизменяемый тип данных, значением
                может быть как изменяемые так и неизменяемые типы данных.</p>
            <p>Методы словарей.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_13_2.png' %}" alt="lesson_13_2"
                 class="python_img i_44">
            <p>Метод .fromkeys() преобразует значения коллекций к ключам словаря, если второй параметр не указан,
                то значениями ключей будет None, если указан, то ключом будет являться указанное
                значение.
            <br>Метод .copy() создаст копию словаря.
            <br>Метод .clear() очистит словарь.
            <br>Метод .setdefault(). Внутрь .setdefault() передается ключ, если таковой уже
                есть в словаре, то ничего не изменится, если такового нет, то создастся новый
                ключ, либо со значением заданным по умолчанию, либо с тем, что мы передадим в
                качестве второго аргумента.
            <br>Метод .pop() вырежет из словаря пару ключ:значение, ключ пары передается в
                качестве аргумента. Если попытаться удалить несуществующий ключ, то получим ошибку KeyError,
                если хотим ее избежать, то в качестве второго параметра можно передать значение,
                которое будет выводиться вместо ошибки, в случае отсутствия переданного ключа.
            <br>Метод .popitem() вырежет из словаря последнюю пару ключ:значение.
            <br>Метод .keys() вернет список ключей словаря.
            <br>Метод .values() вернет список значений словаря.
            <br>Метод .items() вернет пары ключ:значения словаря и преобразует эти пары к кортежам.
            </p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_13_3.png' %}" alt="lesson_13_3"
                 class="python_img i_45">
            <p>Например вот так в цикле for можно вывести пары ключ:значения словаря, по аналогии
                можно вывести только ключи или только значения. Объединить 2 словаря можно с
                помощью оператора **.</p>
            <table class="table">
                <thead class="table-light">
                    <tr><th>Метод</th><th>Описание</th></tr>
                </thead>
                <tbody>
                    <tr><td>.fromkeys()</td><td>Преобразовывает значения коллекции к ключам словаря, второй аргумент - значения этих ключей</td></tr>
                    <tr><td>.copy()</td><td>Создает копию словаря</td></tr>
                    <tr><td>.clear()</td><td>Очищает словарь</td></tr>
                    <tr><td>.setdefault()</td><td>Создает новый ключ, если таковой не имеется</td></tr>
                    <tr><td>.pop()</td><td>Вырезает из словаря пару ключ:значение</td></tr>
                    <tr><td>.popitem()</td><td>Вырезает из словаря последнюю пару ключ:значение</td></tr>
                    <tr><td>.keys()</td><td>Возвращает список ключей</td></tr>
                    <tr><td>.values()</td><td>Возвращает список значений</td></tr>
                    <tr><td>.items()</td><td>Возвращает кортежи пар ключ:значений</td></tr>
                </tbody>
            </table>
            <section class="little_title">Множества</section>
            <p>Множества (set) - это неупорядоченная коллекция уникальных элементов. Уникальных означает, что все повторяющиеся элементы множества будут удалены.
                Очень удобно использовать множества, когда требуется убрать дубли из данных.
                Элементами множества могут быть только неизменяемые типы данных.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_14_1.png' %}" alt="lesson_14_1"
                 class="python_img i_46">
            <p>Для создания множества используются фигурные скобки, но в отличие от словаря в
                множество передаются значения через запятую. Обратите внимание при выводе
                множества на печать значения расположены в хаотичном порядке, это и есть признак неупорядоченной коллекции.
                Как и было сказано выше главное преимущество множеств - удаление дублей, на примере списка из чисел и строки это хорошо видно.</p>
            <p>Методы множеств.
            <br>Метод .add() добавит новое значение в множество.
            <br>Метод .update() добавит в множество значения итерируемого объекта, который содержит несколько элементов.
            <br>Методы .discard() и .remove() выполняют одно и тоже, удаляют переданное значение из множества.
                Единственное отличие, если передать в эти методы элемент, которого нет в списке,
                то .remove() вернет ошибку, а .discard() нет.
            </p>
            <table class="table">
                <thead class="table-light">
                    <tr><th>Метод</th><th>Описание</th></tr>
                </thead>
                <tbody>
                    <tr><td>.add</td><td>Добавляет значение в множество.</td></tr>
                    <tr><td>.update()</td><td>Добавляет значения итерируемого объекта в множество.</td></tr>
                    <tr><td>.remove() и .discard()</td><td>Удаляет переданное значение из множества.</td></tr>
                </tbody>
            </table>
            <p>Операции над множествами.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_15_1.png' %}" alt="lesson_15_1"
                 class="python_img i_47">
            <p>Оператор & вернет результат пересечения множеств, то есть покажет элементы
                повторяющиеся в первом и втором множестве. Оператор | вернет объединение двух множеств,
                исключив все дубли. Оператор - оставит уникальные элементы того множества, из
                которого производилось вычитание. Оператор ^ вернет все уникальные элементы множеств, к которым был применен этот оператор.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_15_2.png' %}" alt="lesson_15_2"
                 class="python_img i_47.1">
            <p>Так это выглядит на практике.</p>
            <section class="little_title">Кортежи</section>
            <p>Последний базовый тип данных, который осталось рассмотреть - кортежи. Кортежи - упорядоченная неизменяемая коллекция элементов.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_16_1.png' %}" alt="lesson_16_1"
                 class="python_img i_48">
            <p>Создать кортеж можно несколькими способами. Первый - передать в переменную данные
                через запятую, необязательно цифры, можно передать также строку или, например, список. Круглые скобки
                свидетельствуют о том, что перед нами кортеж. Второй - передать данные сразу в
                круглых скобках, результат будет таким же. Если передать в переменную один
                элемент, то он не будет являться кортежем. Чтобы единственный элемент являлся
                кортежем нужно предать его с запятой после элемента. Кортеж можно распаковать в
                переменные, работает это как обычное множественное присвоение в python.</p>
            <p>Функция len(), выбор элемента по индексу, а также работа со срезами работает так
                же как и в списках, за тем исключением, что если мы возьмем полный срез при помощи - [:],
                то копия среза не создастся. Зачем нужны кортежи, если есть списки, которые
                выполняют все то же самое и даже больше? Первое - кортежи неизменяемый тип
                данных и по этому эих можно использовать например в качестве ключа словаря или в
                том куске программы где нельзя допустить изменение данных. Второе - кортеж занимает меньше памяти чем аналогичный
                список, в реальных проектах память важный показатель, поэтому там где можно использовать кортеж предпочтительней
                это сделать. Методы .count() и .index() также применимы к кортежам и работают аналогично.</p>
            <section class="little_title">Генераторы списков, множеств и словарей</section>
            <p>Очень полезной и частоиспользуемой конструкцией являются генераторы. Начнем с
                генераторов списков. Фактически генераторы заменяют конструкцию for, но работают значительно быстрее.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_17_1.png' %}" alt="lesson_17_1"
                 class="python_img i_49">
            <p>Найдем все квадраты чисел от 0 до 4. Можно сделать это, как и говорилось выше, в цикле,
                а можно сгенерировать этот же список в одну строку. Всегда, когда можно воспользоваться
                генератором списков, а не циклом for, лучше предпочесть первое. Генератору могут включать
                в себя тернарный оператор либо какие-нибудь условия.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_17_2.png' %}" alt="lesson_17_2"
                 class="python_img i_50">
            <p>Например можно сгенерировать список четных чисел и список нечетных чисел, которые больше пяти.
                Далее сконкатенировать эти списки и с помощью тернарного оператора вывести четным иил нечетным является каждое число из этого нового списка.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_17_3.png' %}" alt="lesson_17_3"
                 class="python_img i_51">
            <p>Генераторы списков могут быть вложенными. Например, с помощью такого вложенного
                генератора списков можно сгенерировать матрицу чисел и далее возвести каждый
                элемент матрицы в квадрат.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_17_4.png' %}" alt="lesson_17_4"
                 class="python_img i_52">
            <p>Также нам доступны генераторы словарей и множеств, используются такие генераторы
                гораздо реже, чем генераторы списков, но знать об этих конструкциях тоже нужно.
                Для того чтобы сгенерировать множество, поменяем квадратные скобки на фигурные, а
                чтобы вместо множества сгенерировать словарь в качестве генерируемой переменной передадим не одно значение, а два, через двоеточие.</p>
            <section class="little_title">Введение в функции</section>
            <p>Можно сказать, что вступление в базовый синтаксис пройдено. Теперь преступим
                к телу каждой программы - функциям. Функции позволяют нам не повторятся, а записать фрагмент кода внутрь функции и в нужный момент вызывать ее.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_18_1.png' %}" alt="lesson_18_1"
                 class="python_img i_53">
            <p>Определяется функция с помощью ключевого слова def. Для вызова функции достаточно
                написать ее имя внутри программы. Внутрь функции можно передать какие-нибудь
                переменные, которые потом будут использоваться внутри тела функции. Для
                использования этих переменных достаточно передать их при вызове функции. Задача на вычисление площади прямоугольника теперь выглядит гораздо компактнее.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_18_2.png' %}" alt="lesson_18_2"
                 class="python_img i_54">
            <p>Но ничего не мешает передать в функцию данные запрошенные у пользователя, обратите
                внимание названия переменных внутри определения функции и названия переменных
                передаваемых внутрь вызова функции могут быть разными.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_18_3.png' %}" alt="lesson_18_3"
                 class="python_img i_55">
            <p>А что если сохранить результат работы функции в переменную и вывести на экран
                результат этой переменной. Мы получим None, почему так произошло? PyCharm подчеркивает 10 строку и
                обработчик проблем сообщает нам, что функция ничего не возвращает. Дело в том,
                что любая функция имеет параметр return и если в этот оператор ничего не передать,
                то функция возвратит значение return по умолчанию, то есть - None.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_18_3.1.png' %}" alt="lesson_18_3.1"
                 class="python_img i_56">
            <p>Теперь, познакомившись с оператором return, приведем программу к правильному виду.</p>
            <section class="little_title">Области видимости</section>
            <p>Возможно вы обратили внимание, что к переменным созданным внутри функции не
                получится обратиться за пределами этой функции, такое поведение касается не
                только функций, но разберем это на их примере.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_19_1.png' %}" alt="lesson_19_1"
                 class="python_img i_57">
            <p>Вот демонстрация того о чем я говорю. Переменная 'a'
                существует внутри функции, а за ее пределами при попытке обращения к ней мы
                получим ошибку, говорящую, что такая переменная не найдена. Переменные
                существующие внутри функции называются локальными, переменные существующие в
                основном теле программы называются глобальными.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_19_2.png' %}" alt="lesson_19_2"
                 class="python_img i_58">
            <p>Нам ничего не мешает создать переменную с одним названием в глобальной области
                видимости и в локальной, правда PyCharm из-за этого на нас немного поругается.
                Переменная 'a' и 'd' демонстрируют нам, что для функций переменные расположенные
                в локальной области видимости приоритетней чем в глобальной, а переменная 'e'
                демонстрирует, что если в локальной области соответствующей переменной не
                обнаружено, то функция обратится к глобальной области видимости и возьмет ее
                оттуда. Изменение одноименных переменных внутри локальной области
                видимости никак не влияет на них в глобальной области, потому что id у таких переменных разные несмотря на одинаковые названия.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_19_3.png' %}" alt="lesson_19_3"
                 class="python_img i_59">
            <p>Если мы все-таки хотим, чтобы изменения переменной в локальной области видимости
                повлияли на нее в глобальной области, то используем инструкцию global. Она
                буквально говорит, что переменные внутри этой инструкции должны интерпретироваться
                как глобальные.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_19_4.png' %}" alt="lesson_19_4"
                 class="python_img i_60">
            <p>Существует еще одна похожая инструкция - nonlocal, которая позволяет изменять
                переменные в ближайшей области видимости, за исключением глобальной. Отсюда возникает
                правило инструкции nonlocal - nonlocal используется только внутри вложенных
                функций. То есть внутри функции some_def_2 мы обращаемся к переменной 'a' определенной внутри функции some_def и изменяем ее, глобальную переменную 'a' мы при этом не затрагиваем.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_19_5.png' %}" alt="lesson_19_5"
                 class="python_img i_61">
            <p>LEGB правило используется интерпретатором для поиска имен. Поиск начинается с
                локальной области и в случае отсутствия имени в локальной области поиск
                продолжается на более широких уровнях.</p>
            <section class="little_title">Именованные аргументы. Передача произвольного числа аргументов</section>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_19_1_1.png' %}" alt="lesson_19_1_1"
                 class="python_img i_62">
            <p>Аргументы мы можем передать классическим способом, как на первом примере, два
                аргумента внутри функции значит два значения мы передаем в вызов функции,
                в таком случае значения встают на места аргументов последовательно. Второй
                вариант, объявить аргументы в произвольном порядке. Третий вариант, объявить
                значение аргумента непосредственно в объявлении функции. Параметры, которые не
                имеют значения внутри объявления функции называются - фактические, в противном случае - формальные.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_19_1_2.png' %}" alt="lesson_19_1_2"
                 class="python_img i_63">
            <p>Причем это не означает, что значение этого аргумента обязательно будет таким, это
                означает, что если такому аргументу не соответствует ни одно значение в вызове,
                то значение будет взято из объявления аргумента внутри функции. Думаю пример понятно иллюстрирует такое поведение.</p>
            <p>Но не всегда мы можем точно знать какое количество аргументов потребуется передать в функцию. На эти случаи существуют два особых параметра - *args и **kwargs.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_19_1_3.png' %}" alt="lesson_19_1_3"
                 class="python_img i_64">
            <p>Параметр *args позволяет передать в функцию произвольное количество фактических
                параметров.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_19_1_4.png' %}" alt="lesson_19_1_4"
                 class="python_img i_65">
            <p>А параметр **kwargs позволяет передать в функцию произвольное количество формальных параметров. Причем параметр **kwargs является словарем, поэтому к параметру **kwargs применимы методы словарей.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_19_1_5.png' %}" alt="lesson_19_1_5"
                 class="python_img i_66">
            <p>Благодаря параметру * также можно распаковать коллекции произвольного количества
                параметров.</p>
            <section class="little_title">Декораторы</section>
            <p>Декораторы - тема, которая по началу может показаться достаточно запутанной и
                непонятной, но ее не стоит пугаться. Постараемся разобраться в ней максимально
                подробно. И первое о чем нужно поговорить - замыкания.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_20_1.png' %}" alt="lesson_20_1"
                 class="python_img i_67">
            <p>Когда в прошлом разделе мы разбирали инструкцию nonlocal мы писали вложенные
                функции и для работы такой конструкции мы исполняли вложенную функцию внутри
                основной. Теперь посмотрим на эти две программы. В обоих случаях мы передаем в
                главную функцию переменную name и во вложенной функции используем ее внутри print().
                В первой программе мы поступили так как поступали ранее, исполнили функцию в теле
                главной функции и после вызвали эту главную функцию передав в нее параметр.
                Результат ожидаемый и логичный - Hello Ilya. Теперь посмотрим на вторую программу.
                Вместо исполнения внутренней функции мы ее возвращаем, а значит внутренняя
                функция нигде не исполняется. И, действительно, если выполнить главную функцию как в
                первом примере мы не увидим никакого результата, а вот если присвоить результат ее исполнения
                какой-нибудь переменной и исполнить программу через эту переменную, то результат
                мы увидим. Почему так происходит? Не напрасно перед переходом к теме декораторов
                мы разобрались с областями видимости. Откуда внутренняя функция во втором случае
                взяла переменную 'name', ведь переменная 'name' является локальной и после
                исполнения функции your_name она должна была исчезнуть. Дело тут в том, что пока
                исполнение главной функции присвоено какой-то глобальной переменной цепочка
                функций закрепленная за этой переменной продолжает существовать.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_20_2.png' %}" alt="lesson_20_2"
                 class="python_img i_68">
            <p>Представим это так. Переменная 'ex' держит возвращаемую функцию say_hello() за нее цепляется функция your_name()
                и вся эта цепочка цепляется за наше глобальное окружение. Таким образом,
                существование в глобальной области видимости глобальной переменной, которой присвоено исполнение
                возвращаемой вложенной функции, позволяет пользоваться переменными внешних окружений вложенных функций. Такое поведение и называется замыканием.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_20_3.png' %}" alt="lesson_20_3"
                 class="python_img i_69">
            <p>Причем каждый новый вызов такой функции создаст свое локальное окружение, внутри
                которого будут содержаться свои локальные переменные.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_20_4.png' %}" alt="lesson_20_4"
                 class="python_img i_70">
            <p>Разобравшись с замыканиями можно перейти к написанию декораторов. Напишем функцию
                decorator_def(), которая в качестве параметра будет принимать какую-то функцию. Далее создадим
                вложенную функцию-обертку выполняющую некоторые действия, и помимо этих действий
                она будет выполнять функцию переданную в качестве параметра основной функции. После вернем функцию-обертку.
                Мы создали обычное замыкание, с которыми мы уже знакомы. Ниже объявим некоторую функцию также выполняющую какое-то действие.
                После всего объявим в глобальной области видимости переменную которая будет
                исполнять нашу функцию декоратор и в качестве параметра будет принимать нашу стороннюю функцию,
                тем самым сцепив наши функции между собой. Исполнив теперь нашу глобальную
                переменную мы увидим, что результат сторонней функции исполнился внутри функции-обертки.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_20_4.1.png' %}" alt="lesson_20_4.1"
                 class="python_img i_71">
            <p>А теперь заменим название 'res' на название нашей сторонней функции, таким образом мы поменяли поведение нашей сторонней функции.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_20_4.2.png' %}" alt="lesson_20_4.2"
                 class="python_img i_72">
            <p>Теперь ничего не мешает передать нам параметр в нашу стороннюю функцию, но ранее мы познакомились с
                параметрами *args и **kwargs, поэтому для того, чтобы постоянно внутри функции wrapper() не
                менять параметры в зависимости от параметров сторонней функции удобней передать в нее параметры *args и **kwargs.
                Также наша функция ничего не возвращает это поведение тоже следует исправить.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_20_4.3.png' %}" alt="lesson_20_4.3"
                 class="python_img i_73">
            <p>Сделаем это примерно так. Функция some_def() теперь независимо от того что и с каким количеством
                параметров мы внутри нее напишем, будет обернута в функцию decorator_def() и
                помимо исполнения тела функции some_def() будут выполняться действия тела функции
                decorator_def().</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_20_4.4.png' %}" alt="lesson_20_4.4"
                 class="python_img i_74">
            <p>Причем теперь мы можем создавать произвольное количество сторонних функций и
                каждую оборачивать в нашу функцию decorator_def(). Оборачивание в
                функцию-декоратор всегда выглядит одинаково: 'название сторонней функции = функция декоратор (название сторонней функции)'.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_20_4.5.png' %}" alt="lesson_20_4.5"
                 class="python_img i_75">
            <p>Такую запись заменяет значок @(название функции декоратора) написанный перед
                функцией, которую нужно декорировать. Вот теперь можно сказать, что мы написали
                полноценный декоратор и декорировали им наши функции. Также можно внутри одной
                программы создать несколько декораторов и обернуть какую-нибудь функцию в
                несколько декораторов. Теперь для закрепления разберем еще несколько более
                реальных примеров, в которых обертывание функции в декоратор будет иметь хоть
                какой-то смысл.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_20_5.png' %}" alt="lesson_20_5"
                 class="python_img i_76">
            <p>Например напишем декоратор, который сортирует строку переданных чисел по
                возрастанию. Функцию map() мы подробнее разберем позже, но говоря кратко, благодаря такой записи как на
                примере, можно передавать в переменную произвольное количество параметров через
                пробел. Внутри самого декоратора создадим функцию-обертку, внутри которой
                создадим пустой список, и внутрь этого списка будем добавлять все переменные
                переданные пользователем, сортировать этот список и возвращать его. Еще один момент, не относящийся к теме декораторов,
                с помощью * перед списком можно вывести его без квадратных скобок по краям, при
                этом данная коллекция все еще будет являться списком.
            Такой декоратор можно объявить один раз и использовать его к любой последовательности
                целых чисел.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_20_6.png' %}" alt="lesson_20_6"
                 class="python_img i_77">
            <p>Или, к примеру, напишем вот такой декоратор, который будет засекать время
                исполнения программы. Снова классический скелет функции-декоратора, внутри
                которого с помощью модуля time засекаем начало и конец выполнения программы, а
                далее возвращаем пользователю разницу этих значений.  Такой декоратор уже
                выглядит достаточно полезным.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_20_7.png' %}" alt="lesson_20_7"
                 class="python_img i_78">
            <p>В декораторы можно передавать параметры. Для этого поверх основной
                функции-декоратора напишем еще одну функцию, которая будет принимать какой-то
                параметр со значением по умолчанию. Такая запись позволяет создавать декораторы,
                в которые можно передать параметр и использовать его внутри функции-обертки.
                Например, в нашем случае сымитируем простановку html тэгов вокруг строки, по
                умолчанию выберем тэг h1, и добавим возможность выбирать тэг самостоятельно в качестве параметра декоратора.</p>
            <p>И остался наверное последний момент в теме декораторов функций, который стоило бы
                обсудить.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_20_8.png' %}" alt="lesson_20_8"
                 class="python_img i_79">
            <p>Хорошим тоном в написании декораторов считается сохранение системного названия
                декорируемой функции и ее описание, методы __name__ и __doc__ позволяют узнать
                эти параметры, что это за методы мы подробнее обсудим, когда перейдем к теме ООП,
                сейчас это не так важно. Так вот, когда функция декорирована ее имя и описание
                меняется на имя и описание функции-обертки декоратора, такого поведения, конечно, хочется избежать.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_20_9.png' %}" alt="lesson_20_9"
                 class="python_img i_80">
            <p>Можно изменить это поведение в ручную, просто заменим имя и описание
                функции-обертки на имя и описание декорируемой функции, как это сделано в
                программе справа, но согласитесь, в каждом декораторе каждый раз писать две лишние строки выглядит как что-то,
                что уже должно быть как-то компактно автоматизировано. И действительно, во
                встроенном в python модуле functools есть декоратор wraps, которым мы декорируем
                функцию-обертку и это декоратор заменит две этих строки, сделав то же самое.</p>
            <p>На этом можно закончить знакомство с декораторами, но, конечно, мы столкнемся с
                ними еще неоднократно.</p>
            <section class="little_title">lambda функции</section>
            <p>lambda функции, другое название - анонимные функции, это так скажем одноразовые функции.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_21_1.png' %}" alt="lesson_21_1"
                 class="python_img i_81">
            <p>Синтаксис lambda функций можно описать как: <br>lambda аргументы: действия,
                совершаемые над этими аргументами<br>
            lambda функции могут принимать один, несколько аргументов или ни одного.
                Использование анонимных функций подразумевает, что вы нигде ее не объявляете, у нее нет названия,
                а результат ее исполнения можно передать в какую-то переменную. lambda функции
                лаконичны и компактны, но внутри lambda функций можно выполнить только одно
                действие над аргументами, поэтому анонимными функциями можно заменить только простые однодейственные функции.</p>
            <section class="little_title">Рекурсивные функции</section>
            <p>Функция в python может вызывать сама себя. Правда такой вызов не бесконечен, он
                ограничен примерно 1000 итераций. Поэтому, чтобы рекурсивная функция срабатывала у нее должен быть выход.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_22_1.png' %}" alt="lesson_22_1"
                 class="python_img i_82">
            <p>Посмотрим на такую рекурсивную функцию. Точкой выхода из нее является прекращение выполнения условия if. А как устроена сама рекурсия.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_22_2.png' %}" alt="lesson_22_2"
                 class="python_img i_83">
            <p>Работают рекурсии именно так. Как только мы доходим до рекурсивного вызова функции
                мы сразу, не доходя доэ второго print() возвращаемся к проверке условия, при этом
                программа запоминает на каком моменте это произошло. И как только условие не выполняется
                мы повторно проходимся по функциям, в которых это условие было выполнение и
                довыполняем эти условия. Поэтому сначала мы 3 раза видим 'До', когда n становится равно 4 условие не
                выполняется и мы идем к начала по этим трем успешно выполненным функциям, поэтому после 3 'До' мы видим 3 'После'.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_22_3.png' %}" alt="lesson_22_3"
                 class="python_img i_84">
            <p>Классическим примером для понимания работы рекурсии являются функции
                вычисления факториала числа и нахождения числа фибоначчи по его порядковому номеру
                последовательности. В данных примерах мы уменьшаем входное значение и выходом из программы будет являться условие для наименьшего значения n.</p>
            <section class="little_title">yield</section>
            <p>Ключевое слово yield превратит функцию в генератор, то есть элементы такой функции можно будет обойти только один раз.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_23_1.png' %}" alt="lesson_23_1"
                 class="python_img i_85">
            <p>Например, напишем функцию gen_func(), внутри которой будем поочередно обходить элементы списка.
                Список из шести элементов можно обойти шесть раз на седьмой мы получим ошибку StopIteration.
                Зачем нужны такие функции. Все достаточно очевидно - они занимают меньше памяти. В
                функциях-генераторах нам не требуется хранить весь список чисел, мы берем первое
                значение и на этом моменте выполнение функции замораживается и запоминает, на
                каком моменте мы остановились, пока мы не решим обратиться к следующему элементу
                списка.</p>
            <section class="little_title">Функция map()</section>
            <p>Функция map() на самом деле возвращает итератор, по которому можно
                пробегаться функцией next(). Первым аргументов функция map() принимает функцию,
                которая последовательно применится к каждому значению второго аргумента,
                переданного в эту функцию.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_24_1.png' %}" alt="lesson_24_1"
                 class="python_img i_86">
            <p>Например преобразуем каждый элемент списка к строке.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_24_2.png' %}" alt="lesson_24_2"
                 class="python_img i_87">
            <p>Или такой пример, с помощью функции map() сначала получим произвольное
                количество переменных преобразованных к списку. А далее опять же с
                помощью функции map() возьмем модуль каждого числа из этого списка. Модуль в python можно взять с помощью функции abs().</p>
            <section class="little_title">Функция filter()</section>
            <p>Функция filter() выводит только те значения итерируемого объекта, к которым применение функции вернет значение True.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_25_1.png' %}" alt="lesson_25_1"
                 class="python_img i_88">
            <p>Например вот так благодаря функции filter() можно отсортировать список строк и
                оставить только те чья длина меньше пяти.</p>
            <section class="little_title">Функция zip()</section>
            <p>последняя популярная функция для работы с итерируемыми объектами - функция zip().</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_26_1.png' %}" alt="lesson_26_1"
                 class="python_img i_89">
            <p>Функция zip() объединяет несколько итерируемых последовательностей и преобразует их
                к кортежам. Заканчивается работы функции zip(), когда достигнут последний элемент самой короткой последовательности.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_26_2.png' %}" alt="lesson_26_2"
                 class="python_img i_90">
            <p>Последовательностей может быть больше двух, а так же кортежи сразу можно
                распаковать с помощью множественного присвоения.</p>
            <section class="little_title">Функция isinstance()</section>
            <p>Ранее тип данных мы проверяли только благодаря функции type(), но есть еще одна функция,
                которая позволяет совершать такую проверку. Первым параметром в функцию
                isinstance() мы передаем тип данных, а вторым объект, тип данных которого мы хотим проверить.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_27_1.png' %}" alt="lesson_27_1"
                 class="python_img i_91">
            <p>Напишем функцию, внутри которой будем поочередно пробегаться по всем элементам списка,
                с помощью функции isinstance() проверять является элемент целым числом, и если да,
                будем плюсовать его к переменной res и возвращать ее. Возвращает функция
                isinstance(), как несложно догадаться, True или False.</p>
            <section class="little_title">Функции all() и any()</section>
            <p>Функции all() и any() возвращают либо True, либо False. Функция all() возвратит True,
                если все значения коллекции, к которой применена функция all(), возвращают True, в противном
                случае будет возвращен False. Функция any() работает так же, но для возвращения
                True достаточно чтобы хотя бы один элемент коллекции приравнивался к True.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_28_1.png' %}" alt="lesson_28_1"
                 class="python_img i_92">
            <p>Обратите внимание, любая пустая коллекция, например, пустой список или пустой словарь, а также ноль, приравниваются к False.</p>
            <section class="little_title">Импорт и установка модулей</section>
            <p>Когда мы говорили про декораторы в одном из примеров мы импортировали декоратор
                wraps из модуля functools. Модули, или библиотеки, в python это любой программный
                файл, содержащий какие-нибудь будь функции, классы или попросту переменные.
                Библиотек в python огромное множество, некоторые из них входят в стандартный
                набор библиотек и устанавливаются вместе с установкой python, а некоторые нужно устанавливать дополнительно.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_29_1.png' %}" alt="lesson_29_1"
                 class="python_img i_93">
            <p>Импортировать модули можно несколькими способами.
            <br>Первый <code>import (название модуля)</code>
            <br>Второй <code>import (название модуля) as (свое название модуля)</code>
            <br>Третий <code>from (название модуля) import (список конкретных объектов этого
                    модуля)</code>
            <br>Чтобы обратиться к методу какого-то модуля импортированного целиком нужно написать
                название модуля и через точку необходимый метод этого модуля, а в тех случаях когда
                мы импортируем конкретные методы достаточно написать их без названия самого
                модуля. Функция dir() позволит посмотреть все методы модуля, но удобнее зайти внутрь
                этой библиотеки и почитать о ее методах подробнее. Для этого достаточно нажать на
                название библиотеки с зажатой клавишей ctrl.</p>
            <p>Устанавливать библиотеки, не входящие в стандартный набор в windows можно командой
                pip install (название модуля), в linux это делается командой sudo apt-get install (название модуля).
                Я использую linux, но пишу в виртуальной среде поэтому также могу пользоваться
                командой pip. Можно устанавливать сразу несколько модулей, перечислив их через запятую.
                А вот импортировать модули в программу через запятую не рекомендуется, для
                каждого нового модуля новая команда import.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_29_2.png' %}" alt="lesson_29_2"
                 class="python_img i_94">
            <p>Конечно, ничего не мешает пользоваться не чужими библиотеками, а написать свой
                модуль и импортировать объекты из него. Например, возьмем декоратор для засекания
                выполнения времени программы, который мы писали ранее поместим его в новый файл и
                импортируем этот декоратор в нашу основную программу. Обратите внимание, модуль time не нужно импортировать
                для обеих программ, достаточно того, что он импортирован в той программе откуда мы забираем функцию, внутри которой использован данный модуль.</p>
            <section class="little_title">Работа с файлами</section>
            <p>Часто придется работать со сторонними файлами, например форматов txt или json. В
                python для работы с файлами используется функция open().</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_30_1.png' %}" alt="lesson_30_1"
                 class="python_img i_95">
            <p>Например, создадим в папке с нашим проектом еще одну папку с названием 'files', а
                внутри этой папки файл 'example.txt'. В файл 'example.txt' добавим дзен python - это свод правил из 20 пунктов,
                который можно увидеть по команде import this, я нашел русские эквиваленты этих правил и добавил их 'example.txt'.
                Для того, чтобы прочитать этот файл воспользуемся функцией open(), первым
                параметром в кавычках напишем путь до нашего файла, пути могут быть абсолютными,
                т.е. начинающиеся с диска иэ проходящие все папки до файла и относительные, т.е. пути относительно того
                файла, в котором мы работаем. В данном примере воспользуемся относительным путем. Вторым параметром явно
                укажем кодировку, параметр encoding, используйте кодировку 'UTF-8', если в вашем файле присутствует кириллица.
                По умолчанию функция open() открывает файл на чтение. Метод .read() выведет все содержимое файла и после того как файл
                будет прочтен, так скажем, каретка, останется на последнем символе, для того чтобы вернуть каретку в начало
                воспользуемся методом .seek() где в качестве параметра укажем к какому символу нужно вернуть каретку. В метод .read()
                тоже можно передать параметр, это число будет означать сколько символов нужно прочитать, а метод .tell()
                расскажет на каком байте, именно байте, мы сейчас находимся, один кириллический символ равняется двум байтам.
                Метод .readline() возвращает верхнюю строку, можно пройтись по файлу в цикле for и благодаря этому методу поочередно
                возвращать каждую строку. Последний метод - .close() каждый файл нужно
                обязательно закрывать, особенно если он был открыт на запись, делается это для того, чтобы избежать возможную потерю данных.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_30_2.png' %}" alt="lesson_30_2"
                 class="python_img i_96">
            <p>Закрытие файла действительно важный момент. И для того, чтобы избежать забывание метода .close() существует
                менеджер контекста with и предпочтительней работать с файлами через него. ОН автоматически закроет файл после всех манипуляций над ним.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_30_3.png' %}" alt="lesson_30_3"
                 class="python_img i_97">
            <p>У функции open() существует еще один параметр - mode. По умолчанию установлен в значение 'r', т.е. файл откроется
                на чтение, для открытия файла на запись заменим 'r' на 'w'. Если файл открыт на запись мы не сможем его прочитать, для
                прочтения нужно открыть файл еще раз с параметром mode в значении 'r'. Метод
                .write() запишет в файл переданную в этот метод строку. Обратите внимание, python дзен я не удалял
                из нашего файла, удалило его как раз открытие файла на запись, каждый раз, когда мы открываем файл на запись его прошлое содержимое удаляется.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_30_4.png' %}" alt="lesson_30_4"
                 class="python_img i_98">
            <p>Нам необязательно создавать новый файл вручную для работы с ним. Мы можем создать новый файл прям внутри функции open, в параметре file напишем несуществующее название файла в
                режиме записи. Файл 'new.txt' с новым содержимым создан по указанному пути.</p>
            <img src="{% static 'alls_articles/articles/base_syntax/pictures/lesson_30_5.png' %}" alt="lesson_30_5"
                 class="python_img i_99">
            <p>Каждый раз удалять содержимое это, конечно, не всегда удобно. Режим дозаписи
                называется 'a', если удалять содержимое не требуется, используйте этот режим.
                Но в режиме 'a' все еще нельзя читать содержимое.
                Режим и для дозаписи и для чтения называется 'a+', правда по умолчанию открытие файла
                в таком режиме установит каретку в конец файла, поэтому для прочтения всего содержимого следует
                сначала установить каретку в начало уже знакомым методом .seek().</p>
            <table class="table">
                <thead class="table-light">
                    <tr><th>Метод</th><th>Описание</th></tr>
                </thead>
                <tbody>
                    <tr><td>.read()</td><td>Выводит все содержимое файла</td></tr>
                    <tr><td>.readline()</td><td>Выводит содержимое файла построчно</td></tr>
                    <tr><td>.readlines()</td><td>Выводит список всех строк файла</td></tr>
                    <tr><td>.next()</td><td>Выводит следующую строку файла</td></tr>
                    <tr><td>.seek()</td><td>Устанавливает каретку в переданную позицию</td></tr>
                    <tr><td>.tell()</td><td>Показывает нынешнюю позицию каретки</td></tr>
                    <tr><td>.write()</td><td>Запишет строку в файл</td></tr>
                    <tr><td>.writelines()</td><td>Запишет последовательность строк в файл</td></tr>
                    <tr><td>.close()</td><td>Закроет файл</td></tr>
                </tbody>
                <thead class="table-light">
                    <tr><th>Режим</th><th>Описание</th></tr>
                </thead>
                <tbody>
                    <tr><td>r</td><td>Режим чтения, режим по умолчанию</td></tr>
                    <tr><td>w</td><td>Режим записи</td></tr>
                    <tr><td>a</td><td>Режим дозаписи</td></tr>
                    <tr><td>r+</td><td>Режим записи и чтения, каретка в начале</td></tr>
                    <tr><td>w+</td><td>Режим записи и чтения, каретка в начале, перезаписывает
                        содержимое</td></tr>
                    <tr><td>a+</td><td>Режим дозаписи и чтения, каретка в конце</td></tr>
                    <tr><td>b</td><td>Добавление b второй буквой к каждому режиму сделает то же, что и без нее, только в бинарном режиме</td></tr>
                </tbody>
            </table>
        </div>
    </div>
{% endblock %}
