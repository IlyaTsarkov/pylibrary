{% extends 'articles/base.html' %}

{% block title %}Django{% endblock %}

{% load static %}

{% block article_content %}
    <div class="container">
        <div class="h2_name">
            <p id="Django">Django</p>
        </div>
        <div class="classic_text">
            <h3 class="h3_name">Введение</h3>
            <p>Django - один из самых популярных backend web-фреймворков на сегодняшний
                день. Backend web-фреймворком предназначены для работы на серверной стороне.
                Кратко говоря, фреймворки это библиотеки преднастроенных параметров. В каждом
                проекте есть какой-то скелет, на который каждый раз тратить время
                нецелесообразно. Именно для экономии этого времени и существуют фреймворки.
                Они создают за вас этот скелет, а их разработчики и комьюнити предоставляют для
                вас <a href="https://docs.djangoproject.com/en/4.0/releases/3.0/" class="links" target="_blink">документацию</a>
                и обучающие материалы, помогающие вам "масштабировать" этот скелет так, как нужно вам.</p>
            <p>Django умеет многое, постараемся со временем тут разобраться во всем. Django
                написан на Python, языке, который занимает второе место в мире по популярности
                и возможно скоро окажется на первом. Как известно теория куда лучше усваивается с
                практикой, поэтому прямо сейчас создадим наш первый сайт на Django.</p>
        </div>
        <div class="classic_text">
            <h3 class="h3_name">Установка Django. Виртуальное окружение. Первый сайт.</h3>
            <p>В этом обучающем материале будут скриншоты кода и результата его исполнения.
                Для написания кода будет использоваться интегрированная среда разработки <a href="https://www.jetbrains.com/pycharm/" class="links" target="_blink">PyCharm</a>.
                Используйте тот редактор, к которому привыкли, это не принципиально.
                Операционная система Linux, команды, исполняемые в командной строке, тоже будут для Linux.
                Рекомендую, если вы решили заниматься программированием, начать использовать Linux как можно раньше, установка его
                рядом с Windows или как единственную систему на вашем устройстве займет пару
                часов, не затягивайте с этим.</p>
            <section class="little_title">Venv</section>
            <p>Устанавливается Django, как и другие библиотеки Python, с помощью системы
                управления пакетами и соответственно команды pip install или apt install в случае
                Linux. Но перед созданием первого проекта создадим виртуальное окружение и
                установим Django в него. Venv - один из наиболее популярных инструментов для
                создания виртуального окружения. Для чего это окружение вообще нужно? Библиотеки
                python постоянно обновляются и у них выходят новые версии. Чаще всего изменения и
                исправления в них незначительны. Но если в одном из ваших старых проектов использовалась
                более старая версия какой-то библиотеки, а впоследствии вы воспользовались этой
                библиотекой для нового вашего проекта и обновили ее, то это может привести к
                проблемам с работоспособностью ваших прошлых проектов. Поэтому лучше не игнорировать виртуальное окружение.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/venv_1.png' %}" alt="venv_1" class="python_img i_1">
            <p>Как видно создается виртуальное окружение всего одной командой, и всего одной
                командой запускается. Рассмотрим немного подробнее. Зачастую библиотека venv
                устанавливается сразу с установкой python, однако, если вы используете дистрибутив Linux - Ubuntu, она там может быть не установлена.</p>
            <p>Устанавливается она следующей командой:<br>
            <code>sudo apt install python3.* venv</code>, где вместо * пишется ваша версия
                python. Например, 3.8. Узнать версию python можно командой:<br>
            <code>python3 --version</code>.</p>
            <p>После успешной установки переходим в папку, где хотим создать виртуальное
                окружение и пишем команду как на скриншоте:<br>
            <code>python3 -m venv venv</code>, где первое упоминание venv - название
                исполняемого модуля, а второе - его название. Часто виртуальное окружение так и
                называют - venv. В итоге в выбранной папке создается каталог venv/, где хранится
                копия интерпретатора python. В этот каталог будут устанавливаться необходимые нам библиотеки для работы над проектом.</p>
            <p>Осталось запустить окружение. Команда:<br>
            <code>source venv/bin/activate</code>, если после этого около названия вашего устройства появились
                круглые скобки с названием вашего окружения, (venv), в случае примера, то вы
                успешно запустили виртуальное окружение. Команда <code>deactivate</code> для
                выхода из виртуального окружение.</p>
            <section class="little_title">Установка django</section>
            <p>Устанавливается django командой:<br>
            <code>pip install django</code>, загрузка может не начинаться несколько секунд, стоит
                подождать. Не забывайте, пишем мы эту команду в виртуальном окружении, иначе
                зачем мы его вообще создавали, кстати команда pip install будет работать только внутри виртуального окружения.
                Если все-таки вы хотите установить django для всего вашего python, а не только для venv, то воспользуйтесь командой:<br>
            <code>sudo apt install python3-django</code>. Проверить успешность установки в любом
                из двух случаев можно командой:<br>
            <code>django-admin --version</code>, если в ответ на нее вы получили три цифры,
                разделенные точкой, то установка прошла успешно.</p>
            <p>Итак, у нас есть виртуальное окружение с установленным в него django, можно
                наконец создать свой первый проект.</p>
            <section class="little_title">Создание нового проекта</section>
            <p>Находясь в виртуальном окружении введите команду:<br>
            <code>django-admin startproject (название проекта)</code>, например firstsite. Все,
                первый Django проект создан. На одном уровне с папкой venv должна появится папка с названием вашего проекта. Вот содержание этой папки.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/startproject.png' %}" alt="startproject" class="python_img i_2">
            <p>На одном уровне, как и говорилось папки venv и firstsite, внутри папки firstsite еще одна папка
                с названием проекта и файл manage.py и внутри уже второй папки с названием проекта
                файлы: __init__.py, asgi.py, settings.py, urls.py, wsgi.py. Это тот самый скелет,
                стандартная структура любого, только что созданного, проекта. Подробнее о каждом из них чуть далее,
                а сейчас напишем еще одну команду, находясь в первой папки с названием проекта:<br>
            <code>python manage.py runserver</code>, скорее всего вы увидите сообщение от
                терминала, говорящее о необходимости совершить миграции, сейчас не обращаем на
                это внимания. А чуть ниже вы увидите адрес, скорее всего он будет такой: http://127.0.0.1:8000/,
                аналогом является http://localhost:8000/, где 8000 это восьмидесятый порт, к
                которому разработчики django добавили еще два нуля, просто для того, чтобы отличать на каком фреймворке
                создан сайт. Кликните по нему или скопируйте и вставьте в командную строку браузера. Вы увидите следующее.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/startproject_example.png' %}" alt="startproject_example" class="python_img full_screen i_3">
            <p>Так выглядит стартовая страница Django и если после всех этих действий у вас
                получилось то же самое, то вы все сделали правильно. Для того чтобы деактивировать сервер нажмите <code>ctrl + c</code> в терминале.</p>
            <section class="little_title">Структура проекта</section>
            <p>Для запуска сервера мы воспользовались файлом manage.py, этакого "менеджера" проекта,
                с помощью которого выполняются административные задачи. К его помощи мы будем обращаться постоянно. Все доступные команды можно увидеть с помощью команды:<br>
            <code>python manage.py help</code><br>Во второй папке с названием проекта содержаться:
            <br>__init__.py - пустой файл, говорящий python'у воспринимать данную директорию в
                качестве пакета.
            <br>settings.py - файл с настройками проекта.
            <br>urls.py - файл, в котором будут прописываться url адреса.
            <br>wsgi.py - с помощью этого файла приложение может работать с веб-сервером по протоколу wsgi.
            <br>asgi.py - с помощью этого файла приложение может работать с веб-сервером по протоколу asgi.
            <br>А также после первого запуска добавился файл db.sqlite3 - база данных проекта. Базы данных отдельная, большая
                тема и подробнее о ней в будущем мы конечно поговорим. SQlite - не единственная
                СУБД, сказать честнее чаще всего в реальных проектах используется не она, а например MySQL или PostgreSQL, но пока остановимся на SQlite.</p>
            <section class="little_title">settings.py</section>
            <p>settings.py является не менее важным файлом, чем manage.py, и хотелось бы
                поговорить о нем чуть подробнее. Откройте его и пробежимся по нему сверху вниз.
            <br>BASE_DIR - переменная, в которой указан путь к папке проекта, изначально вычислен
                автоматически.
            <br>SECRET_KEY - сгенерированный случайный набор символов, секретный ключ проекта,
                лучше его никому не знать, а если кто-то его узнал, то достаточно заменить в нем некоторые символы.
            <br>DEBUG - режим отладки, в значении TRUE - включенБ в значении FALSE - отключен. При
                включенном режиме мы получаем более полную информацию об ошибках, обычно при разработке режим отладки
                всегда включен и выключается, когда проект выгружается в сеть.
            <br>ALLOWED_HOSTS - по умолчанию пустой список, в него добавляются имена доменов или хостов, которые может обслуживать этот проект django.
            <br>INSTALLED_APPS - список зарегистрированных приложений, подробнее о них позже.
            <br>MIDDLEWARE - список зарегистрированных посредников, подробнее о них позже.
            <br>ROOT_URLCONF - путь к файлу urls.py, уровня проекта.
            <br>TEMPLATES - настройки для работы с шаблонами, по умолчанию используется шаблонизатор - djangotemplates, естественно существуют и другие.
                Django использует HTML шаблоны для визуальной составляющей сайта.
            <br>WSGI_APPLICATION - настройка, связанная с разворачиванием сайта.
            <br>DATABASES - настройки, где описаны базы данных и их адрес.
            <br>AUTH_PASSWORD_VALIDATORS - настройки, для ограничения паролей к аккаунтам,
                которые имеют доступ к сайту. Например, длина пароля.
            <br>LANGUAGE_CODE - язык сайта, по умолчанию английский, для изменения например на
                русский, удалите 'en-us' напишите - 'ru'.
            <br>TIME_ZONE - часовой пояс.
            <br>USE_I18N - если True, то автоматически все системные сообщения будут выводится на
                языке указанном в LANGUAGE_CODE, если False - то нет.
            <br>USE_TZ - если True, значение даты и времени будет отображаться соответствуя
                указанной в TIME_ZONE временной зоне.
            <br>STATIC_URL - настройка для работы со статическими файлами.
            <br>DEFAULT_AUTO_FIELD - необходим для моделей, у которых нет поля с primary_key =
                True. И для управления этими полями.</p>
            <p>Прямо сейчас поработаем с настройками и добавим первое приложение нашего сайта.</p>
        </div>
        <div class="classic_text">
            <section class="little_title">Первое приложение</section>
            <p>По сути, сайт на django - это набор приложений отвечающих за разный его функционал.
                Можно создать сайт состоящий из одного приложения, но зачастую их несколько.
                Давайте начнем создавать наш первый сайт. Пусть это будет сайт, который умеет генерировать
                случайный логин, логины часто нужны, например в играх или в различных сайтах и приложениях,
                но иногда не хочется их придумывать, пусть этот сайт решает эту проблему. Генерация логина
                единственный функционал нашего первого сайта, поэтому для него хватит одного приложения.
                Создадим его командой, предварительно остановив сервер, если он запущен:<br>
            <code>python manage.py startapp genlogins</code></p>
            <img src="{% static 'alls_articles/articles/django/pictures/startapp.png' %}" alt="startapp" class="python_img i_4">
            <p>Создалась папка с нашим приложением, будем говорить о ее содержимом постепенно, но
                сначала добавим приложение в наш проект. Откройте файл settings.py и в переменную
                INSTALLED_APPS добавьте в конец наше созданное приложение. Достаточно в кавычках
                написать название приложение, оно такое же, как и у его папки, genlogins в нашем случае. Примерно так.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/settings_apps.png' %}"
                 alt="settings_apps" class="python_img i_5">
            <p>Первое приложение создано и добавлено в проект. Но если мы теперь заново запустим
                наш сервер, то никаких изменений мы не увидим. Во-первых, приложение есть в
                проекте, но ему не присвоен никакой адрес, а во-вторых, файл views.py, как
                раз отвечающий за отображение - содержит только импорт функции render из
                django.shortcuts, то есть по сути пустой. Давайте это исправим.</p>
            <section class="little_title">Введение в urls</section>
            <p>Обычно каждому разделу сайта присвоен свой url адрес, название которого примерно описывает,
                что происходит по этому адресу. Возьмем наш сайт, адрес 127.0.0.1:8000 - это
                адрес нашей стартовой страницы, когда мы приобретем доменное имя и присвоим его
                сайту, этот адрес заменится на доменное имя. Как к примеру домен twithc.tv - это
                стартовая страница стриминговой платформы twithc. Но каждому стримеру этой платформы присвоен
                свой url адрес, который указывается через / после доменного имени - twithc.tv. Думаю,
                если вы пользуетесь интернетом, то вы прекрасно это знаете, но я не смог проигнорировать это введение.
                Для страниц (приложений) нашего сайта мы тоже хотим присваивать свои url адреса.
                По умолчанию в новом проекте, в главном файле urls.py содержится один адрес, admin/,
                слово главном я использовал, потому что в будущем мы создадим файл urls.py для каждого нашего приложения.
                Этот адрес ведет нас на страницу авторизации в панель администратора нашего
                сайта. Введем его после 127.0.0.1:8000/.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/admin_pannel_example.png' %}" alt="admin_pannel_example" class="python_img full_screen i_6">
            <p>Я прописал в адресной строке только admin, /login/?next=/admin/ добавилось автоматически, сейчас
                не обращайте на это внимания. Перед нами открылось окно авторизации в панель администратора,
                ее мы коснемся позже. Сейчас мы перешли по этому адресу только для того, чтобы
                лучше понять идею url адресов.</p>
            <section class="little_title">Стартовая страница</section>
            <p>Конечно, взлетающая ракета на нашей стартовой странице выглядит красиво, но мы
                все-таки хотим создать свою стартовую страницу. Рассмотрим скриншот.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/first_view.png' %}" alt="first_view" class="python_img full_screen i_7">
            <p>Начнем с главного файла urls.py. Функция path из django.urls помогает создавать
                нам новые url адреса, она принимает два значения, название и то, какое представление
                должно отработать при переходе по ней. Название адреса всегда можно изменить,
                например, заменив 'admin/' на 'adminpanel/', ничего не изменится, кроме того,
                что авторизация в панель администратора будет открываться по адресу adminpanel.
                Со вторым значением интересней, в случае admin мы используем представление site.urls
                из модуля django.contrib. В случае стартовой страницы мы теперь хотим использовать
                наше приложение genlogins и для этого в его файле views.py создадим первое и самое примитивное представление.
            <br>В файле views.py напишем самую простую функцию python, назовем ее start и
                принимать она будет один параметр request. Для того чтобы отобразить текст на
                странице, воспользуемся классом HttpResponse из django.http. Возвратим в нашей функции start
                HttpResponse с каким-нибудь значением, словом START в данном случае. Не забудьте
                импортировать файл views.py в файл urls.py (строка 18 файла urls.py). Теперь запустим сервер заново.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/first_view_example.png' %}" alt="first_view_example" class="python_img i_8">
            <p>И увидим, что вместо взлетающей ракеты перед нами пустая страница со значением,
                возвращаемым классом HttpResponse. Обратите внимание адрес все тот же - 127.0.0.1:8000/.</p>
            <p>Подытожим. Сначала пользователь переходит по какому-то пути, для этого пути ищется
                соответствие в файле urls.py, второй параметр функции path отправляет запрос в файл,
                в котором находится указанное представление, представление отрабатывает и его результат
                выводится пользователю по указанному им адресу. И для тренировки добавим путь, допустим, 'end/',
                ведь файл views.py может содержать столько представлений, сколько url адресов используется на нашем сайте.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/first_view_2.png' %}" alt="first_view_2" class="python_img full_screen i_9">
            <p>И посмотрим на результат.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/first_view_example_2.png' %}" alt="first_view_example_2" class="python_img i_10">
            <p>По адресу 127.0.0.1:8000/end отобразилось слово END. Думаю теперь идея этого механизма
                полностью понятна. Но согласитесь, страница, на которой просто отображается текст это достаточно скучно.
                И как известно, за визуализацию, в том числе за визуализацию сайтов, отвечает такой
                раздел программирования, как frontend.HTML, CSS и JavaScript - три столпа, на которых
                стоит frontend. И визуализация django сайтов не исключение.</p>
            <section class="little_title">Шаблоны</section>
            <p>Я здесь не буду объяснять как работают HTML, CSS и JavaScript, все-таки frontend -
                это отдельная и большая тема, поэтому предполагается, что это все вам уже известно.
                Сначала нужно понять, где писать наши шаблоны.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/templates_mkdir.png' %}" alt="templates_mkdir" class="python_img i_11">
            <p>Внутри нашего приложения genlogins создадим папку templates, и внутри папки templates
                создадим еще папку с названием нашего приложения, то есть genlogins. Такая структура папок
                создается в каждом приложении. Сделаем простой набросок нашего сайта</p>
            <img src="{% static 'alls_articles/articles/django/pictures/templates_learn_1.png' %}" alt="templates_learn_1" class="python_img i_12">
            <p>Вот так теперь выглядит структура папок нашего проекта. В файле index.html добавим тэг
                h1 для названия, и тэг p для краткого описания. Теперь отобразим этот шаблон на
                стартовой странице, для этого в файле views.py возвратим этот шаблон, только уже не
                через класс HttpResponse, а через функцию render из django.shortcuts. Первым параметром
                будет являться аргумент request нашей функции, который является адресом нашего
                запроса, а вторым - путь до нашего шаблона, который можно написать просто как
                название приложения / название файла, поэтому и создается именно такая структура папок для шаблонов.
                Взглянем на нашу стартовую страницу теперь.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/templates_learn_1_example.png' %}" alt="templates_learn_1_example" class="python_img i_13">
            <p>Параметры request и template_name функции render являются обязательными. Но для
                этой функции существуют еще четыре необязательным параметра, один из которых context -
                словарь значений для добавления их в шаблон.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/templates_learn_2.png' %}" alt="templates_learn_2" class="python_img i_14">
            <p>Добавляется в виде обычного python словаря, в фигурных скобках
                парой 'ключ':'значение'. Для добавления значения из этого словаря в шаблон нужно в
                двойных фигурных скобках написать ключ необходимого значения.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/templates_learn_2_example.png' %}" alt="templates_learn_2_example" class="python_img i_15">
            <p>Вот так это будет выглядеть на странице. То что мы сделали можно считать введением в шаблонизаторы.</p>
            <section class="little_title">Тэг form</section>
            <p>В каком виде мы хотим выводить наш сгенерированный логин? Сразу вспоминается сайт
                random.org, где задается диапазон значений и в окне вывода
                на этой же странице отображается случайное число из этого диапазона.
                Пусть в нашем логине тоже можно будет выбрать количество символов, но логины, например в 10 символов, вряд ли кому-то пригодятся,
                так же как и в 1 символ, поэтому пусть наш логин будет ограничен диапазоном от 2 до 5 символов.
                Это наверное мало, но так код для примера получится компактнее, а зная как
                сделать выбор от 2 до 5, можно сказать, что вы знаете, как сделать выбор от n до n. В html есть тэг form,
                который поможет нам реализовать такой функционал. Но пусть логин будет отображаться не на той же странице, а на новой.
                Да удобней для пользователя было бы отображать логин на этой же странице, но для обучения и понимания лучше сделать это сделать на другой.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/html_forms.png' %}" alt="html_forms" class="python_img full_screen i_16">
            <p>Вот так мы это реализуем. Во-первых, добавим в начало нашего шаблона
                более понятное описание для чего нужен этот сайт, а во-вторых добавим две формы.
                Первая форма дает нам возможность сгенерировать логин жестко заданной длины, а
                вторая в диапазоне выбранных значений. Выпадающий список создается внутри тэга select, где
                внутри тэгов option создаются значения этого выпадающего списка. Обратите внимание воспринимается
                значение заданное в параметре value, а то, что написано внутри тэга это
                информация для пользователя, так во второй форме внутри тэга перед цифрами
                добавлены слова от и до, но в параметрах value находятся просто значения. Для
                совершения действия перехода на новую страницу используется тэг input с параметром
                type в значении submit. Для того чтобы перейти на какую-то страницу, ее сначала нужно создать.
                Создадим файл login.html рядом с основным нашим файлом index.html. И напишем там всего один тэг h1,
                с текстом 'Ваш логин:'. Заменим ранее созданный url end на your_login, а так же заменим функцию
                end на функцию login и будем ссылаться на нее. В функции path появился еще и третий необязательный
                параметр name в значении login. Он нужен для того, чтобы ссылаться не к имени
                url, которое видит пользователь в адресе сайта, а к имени заданному в параметре name.
                Дело в том, что у реального проекта может появиться необходимость изменить
                видимое значение url, и чтобы не менять так же ссылку на этот url во всех местах проекта,
                легче ссылаться к его имени, потребность в изменении которого, может появиться с
                гораздо меньшей вероятностью. Ссылаемся мы к этому имени в параметре action тэга
                form. Запись &#123;% %&#125; - эквивалент записи &#123;&#123; &#125;&#125;, используемой
                выше, а полная запись
                этого параметра ="&#123;% url 'login' %&#125;" - эквивалент записи ="your_login", то есть явной ссылки на url
                страницы, которую нужно открыть. После всех этих манипуляций наша домашняя страница стала выглядеть так:</p>
            <img src="{% static 'alls_articles/articles/django/pictures/html_forms_example.png' %}" alt="html_forms_example" class="python_img i_17">
            <p>Теперь можно выбрать значения из выпадающих списков и нажать на кнопку рядом.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/html_forms_example_2.png' %}" alt="html_forms_example_2" class="python_img i_18">
            <p>При нажатии на любую из обеих кнопок мы будем попадать на страницу, на которой написано 'Ваш логин: '.
                Обратите внимание на url этой страницы, во-первых, она находится по адресу
                your_login, а
                во-вторых, через знак вопроса заданы значения. Конкретно в этом случае, я нажал на
                кнопку 'Сгенерировать логин в заданном диапазоне значений', при заданном диапазоне от 3 до 5, и
                это отобразилось в url адресе открывшейся страницы.</p>
            <section class="little_title">Реализовываем необходимый функционал</section>
            <p>Вот так, совсем не сложно, мы сделали набросок нашей страницы, с описанием функционала и с рабочими формами.
                Но основной функционал все еще не реализован, мы не получаем наш сгенерированный логин. Сейчас это исправим.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/genlogins_work.png' %}" alt="genlogins_work" class="python_img full_screen i_19">
            <p>При реализации этого функционала я решил, что при нажатии на кнопку для жестко
                заданной длины и для случайной длины будут открываться разные страницы,
                соответственно называющиеся your_login и your_rand_login. Это можно было бы
                реализовать и на одной странице, но мне показалось что так нагляднее. Поэтому в коде
                появились пара незначительных изменений. Добавился новый url your_rand_login, ссылающийся
                на функцию rand_login. Соответственно в файле index.html поменялся параметр
                action с ="&#123;% url 'login' %&#125;" на ="&#123;% url 'rand_login' %&#125;" для второй формы.
                Помимо этого в файле index.html тэги option я написал в строку только для того, чтобы на одном
                скриншоте уместить все изменения, вам этого делать не следует. А так же заменил параметры name тэга select у второй
                формы с from и to на from_char и to_char соответственно, это сделано из-за того,
                что при программировании в фале views.py from воспринималось как команда импорта python,
                а не как переменная. Я думаю, то что код поддался небольшому рефакторингу это наоборот хорошо, поскольку это
                имитирует полностью естественный и натуральный процесс программирования. Теперь перейдем к файлу views.py.
            <br>В возвращаемой функции render снова появился третий параметр, и ключ этого параметра я добавил внутрь
                тэгов h2 файлов login.html и random_login.html. Эти ключи будут ссылаться ну случайно сгенерированные
                наборы символов, переменная your_login для функции login и переменная
                your_rand_login для функции rand_login, которые изначально будут являться пустой строкой.
            В обеих функциях создадим переменную alphabet, куда поместим все буквы русского
                алфавита, кроме 'ёьыъ', исключение этих букв, как вы понимаете, необязательно. Теперь
                нам нужно получать данные из наших форм. Делается это благодаря методу GET.get. Обратите внимание на
                строки 13, 28 и 29 файла views.py. Ссылаться на формы мы можем по значению параметра name тэга select. Так в
                случае функции login нам достаточно взять одно значение, а в случае функции rand_login нам нужно взять два значения.
                Параметр value тэга option изначально является строковым типом, то есть str, нам же нужен целочисленный тип, то есть int.
                Делается это оборачиванием нашего запроса в функцию int. Далее импортируем модуль
                random, и благодаря ему, выбираем случайный символ из переменной alphabet и
                прибавляем его к переменной, которую хотим вывести, с помощью random.choice.
                Повторяется это действие в цикле for столько раз, сколько задано в переменной
                length для функции login и в переменной random_length для функции rand_login.
                Random_length выбирает случайное значение, с помощью функции random.randint, которая
                в качестве параметров принимает переменные from_char и to_char. Думаю теперь вам
                понятна каждая строка, которую мы написали. Откройте сайт и убедитесь, что все работает.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/genlogins_work_example.png' %}" alt="genlogins_work_example" class="python_img i_20">
            <p>Вот пример работы нашего сайта, обратите внимание на url адрес, диапазон значений выбран от 2 до 5, а возвращенное слово состоит из четырех символов.</p>
            <p>Теперь на сайт работает так как мы задумали, но конечно функционал можно доработать как вам захочется.
                Например, можете предоставлять пользователю выбор между русским и английским алфавитом, а на страницу с
                результатом добавить кнопку "вернуться к выбору параметров", ведь сейчас, для того
                чтобы вернуться на главную страницу, нужно
                нажимать стрелочку "назад" в браузере.</p>
            <p>Добавить эту кнопку можно очень просто, например так:</p>
            <img src="{% static 'alls_articles/articles/django/pictures/genlogins_work_2.png' %}" alt="genlogins_work_2" class="python_img i_22">
            <p>Думаю объяснять тут нечего.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/genlogins_work_2_example.png' %}" alt="genlogins_work_2_example" class="python_img i_24">
            <p>Теперь на странице с результатом появилась кнопка, при нажатии на которую мы переходим обратно на домашнюю страницу.</p>
            <section class="little_title">Внешний вид</section>
            <p>Мы создали сайт, который работает и выполняет необходимую нам задачу. Но он выглядит достаточно просто.
                Как известно, за внешность сайта отвечает css, а помогают ему такие мощные фреймворки как, например, bootstrap.
                Давайте с помощью css и bootstrap сделаем наш сайт посимпатичнее.
                Добавим bootstrap на наш сайт. Bootstrap подключается как обычно.
                Заходим на страницу <a href="https://getbootstrap.com/docs/5.1/getting-started/introduction/" class="links" target="_blink">документации</a>
                bootstrap, копируем css link и размещаем его вначале наших html файлов.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/bootstrap_css_add.png' %}"
                 alt="bootstrap_css_add" class="python_img i_25">
            <p>Сделаем это таким образом, и из документации возьмем готовые стили для наших
                кнопок. Также поместим весь на html внутрь тэга div с классами container и
                text-center. Еще подключим css файл к нашему проекту. CSS в django подключается
                не так как в обычном HTML. В django для этой цели тоже используется тэг link, но в
                параметре href пишется не просто путь к файлу, а конструкция следующего вида:
                &#123;% static 'путь к файлу' %&#125;, а также в начале шаблона подключаем статические файлы
                специальным тэгом: &#123;% load static %&#125;. Для статических файлов создадим папку static и
                внутри этой папки еще папку css и уже в этой папке создадим файл style.css. В этом css файле застилизуем генерируемый логин.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/bootstrap_css_add_example.png' %}" alt="bootstrap_css_add_example" class="python_img full_screen i_26">
            <p>Теперь зайдем на наш сайт и обновим страницу. Наш сайт стал выглядеть намного интересней.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/bootstrap_css_add_example_2.png' %}" alt="bootstrap_css_add_example_2" class="python_img full_screen i_27">
            <p>Еще я добавил кнопку обновления страницы, чтобы не использовать f5. Как я это сделал можно посмотреть на первом скриншоте.</p>
            <section class="little_title">Первый сайт на django готов</section>
            <p>Мы сделали наш первый сайт. Как по мне, получилось неплохо. Конечно, это очень простой сайт, для создания
                которого использовалась малая часть возможностей django. Но надеюсь его создание сформировало у вас общее представление о работе
                с этим мощным и функциональным фреймворком. Мы не пользовались базами данных, панелью администратора, мы воспользовались
                библиотекой bootstrap и подключили css файл, но есть еще много моментов связанных
                с шаблонами, которые мы позже обсудим, и вообще нам предстоит разобрать еще очень многое. Надеюсь вы не просто повторяли за мной,
                а экспериментировали с кодом, для того, чтобы лучше понять как все это устроено.</p>
            <p>Ну что, предлагаю немного отдохнуть и приступать к созданию второго сайта.</p>
            <p>Весь код сайта genlogin вы можете найти на моем <a href="https://github.com/IlyaTsarkov/django_firstexample" class="links" target="_blink">github</a>
                и там же, при необходимости, скачать его.</p>
            <h3 class="h3_name">Базы данных. Панель администратора. Второй сайт.</h3>
            <p>Во втором сайте, как заявлено в названии, хотелось бы уделить внимание базам
                данных и панели администратора. Для освоения баз данных можно создать сайт, на
                котором будут выкладываться какие-нибудь, назовем это, посты. И должны они быть оформлены
                в одинаковом формате, допустим у них есть название, описание и картинка, самый очевидный набор
                информации, который сразу приходит в голову. Я не хочу писать сайт-блог, на
                который можно добавлять новые посты. Или сайт-портфолио, на который
                можно прикреплять свои новые проекты, может мне, конечно, так кажется, но эти идеи для сайтов используются в
                любом обучающем материале. Это, действительно, достаточно универсальные, полезные и при этом не сложные идеи
                для реализации, и в обоих этих случаях мы будем использовать базы данных. Но мне захотелось придумать что-нибудь
                другое. Я как человек с язвенной болезнью должен следить за своим питанием, хоть
                в последнее время я зв этим и не слежу, но в теории это должно быть так. Давайте
                напишем сайт, который будет состоять из двух приложений. Первое - раздел с
                блюдами, которые можно употреблять людям с язвой, второе - некая форма,
                состоящая из семи дней недели, в которой для каждого дня можно комбинировать блюда из первого раздела, тем
                самым составляя недельный рацион. Мне кажется, что приложение, в которое можно добавлять блюда и
                составлять из них рацион на неделю (хотя подозреваю, что таких приложений огромное множество) может быть кому-то полезно. И созданный
                нами сайт можно легко довести до ума, добавив возможность регистрации пользователей,
                создание личного кабинета каждого пользователя со своими вариантами блюд и
                рационом, ну и прочее. Все едят и многие следят за тем, что едят, так что
                придумать можно многое. Но поскольку это всего второй сайт ограничимся только знакомством с базами данных.</p>
            <section class="little_title">Панель администратора</section>
            <p>Перейдем уже в PyCharm и создадим второй наш проект. Точно так же как делали это в прошлый раз. У меня пока есть только
                представление как это выглядит в голове, нет никакого даже самого простенького наброска, поэтому начинаем мы с вами действительно с нуля.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_first.png' %}" alt="startproject_first" class="python_img i_28">
            <p>В консоли создадим новый проект и сразу же создадим два задуманных приложения и не забудем зарегистрировать их в файле settings.py.</p>
            <p>После этого запустим сервер и перейдем по адресу http://127.0.0.1:8000/admin в прошлом проекте мы уже это делали.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_adminpannel_1.png' %}" alt="startproject_adminpannel_1" class="python_img i_29">
            <p>Для авторизации нам требуется логин и пароль, предварительно их нужно создать. Для этого сначала выключим сервер комбинацией ctr + c.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_adminpannel_2.png' %}" alt="startproject_adminpannel_2" class="python_img i_30">
            <p>Делается это командой
            <br><code>python manage.py createsuperuser</code>
            <br>Почту можно пропустить, а вот к паролю есть требования, их видно на скриншоте, в учебном примере я все-равно
                использую простой пароль, но на реальных проектах, конечно, лучше прислушаться к
                советам по паролю от Django. Логин и пароль готовы, теперь можем запустить сервер снова и авторизоваться.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_adminpannel_3.png' %}" alt="startproject_adminpannel_3" class="python_img i_31">
            <p>Увидим мы примерно следующее. Группы и пользователи. У нас есть какой-то
                функционал этих сущностей и в целом мы уже можем с ними взаимодействовать. Перейдем, например, в пользователей.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_adminpannel_4.png' %}" alt="startproject_adminpannel_4" class="python_img i_32">
            <p>Перед нами база данных, в которой хранятся пользователи. Я не буду тут подробно
                останавливаться на устройстве баз данных в целом, я планирую написать материал по SQL, возможно к моменту, когда вы это читаете он уже написан.
                SQL на базовом уровне очень прост для освоения, и даже если вы с этим языком
                вообще не знакомы, то того, что мы увидим при создании этого сайта вам должно
                хватить для понимания устройства баз данных. Базы данных в программировании это таблицы, так база данных пользователей
                это таблица со столбцами, которые мы видим на скриншоте (USERNAME, EMAIL ADDRESS, FIRST NAME, LAST NAME, STAFF STATUS),
                а строками соответственно пользователи с данными параметрами.</p>
            <p>Весь backend сайтов основан на базах данных, это удобно и в этом несложно разобраться.
                Давайте создадим теперь свою базу данных для приложения menu.</p>
            <section class="little_title">Модели</section>
            <p>Базы данных в django называются моделями и создаются модели в файле models.py.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_1.png' %}" alt="startproject_models_1" class="python_img i_33">
            <p>Для этого перейдем в этот файл и создадим первую модель. Создаются в django модели
                с помощью классов. Наследуется этот класс от класса models. Models. Теперь, что касается самих столбцов, в данном случае мы создали 5
                столбцов с соответствующими названиями и соответствующими типами. Типов столбцов
                достаточно много, так CharField тип используется для небольших текстов, а TextField
                для больших. IntegerField для чисел, ImageField для изображений, со всеми типами можно
                ознакомиться в <a href="https://docs.djangoproject.com/en/4.0/ref/models/fields/" target="_blank" class="links">документации</a>.
                У всех типов есть необязательные и обязательные параметры, один из которых max_length, внутри которого как
                понятно из названия мы прописываем максимально допустимую длину символов для этого столбца.
                Параметр upload_to у типа ImageField хранит путь до места, в котором будут храниться все добавляемые в это поле изображения.</p>
            <p>Поcле создания базы данных ее нужно сынтегрировать с нашим приложением</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_2.png' %}" alt="startproject_models_2" class="python_img i_34">
            <p>Делается это командой
            <br><code>python manage.py makemigrations</code>
            <br>Консоль говорит нам, что миграция готова. Файл 0001_initial.py, который создается
                автоматически, содержит базу с нашими полями и с дополнительным полем id,
                это поле в SQL мы должны создавать в ручную, а django это делается за нас. Это поле
                нужно по большей части для взаимодействия баз друг с другом.</p>
            <p>миграция создана, но она еще не подтверждена.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_3.png' %}" alt="startproject_models_3" class="python_img i_35">
            <p>Сделаем это командой
            <br><code>python manage.py migrate</code>
            <br>Среди списка системных миграций мы видим еще и нашу созданную миграцию menu. Как вы уже наверное поняли новая модель должна отображаться в панели администратора.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_4.png' %}" alt="startproject_models_4" class="python_img i_36">
            <p>Для того, чтобы зарегистрировать и отобразить базу данных в админке перейдем в
                файл admin.py и импортируем базу данных Menu из файла models.py и зарегистрируем ее командой
            <br>admin.site.register(имя базы)
            <br>Теперь запустим сервер, перейдем в админку и посмотрим, что изменилось.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_5.png' %}" alt="startproject_models_5" class="python_img i_37">
            <p>Добавилась модель с именем Menus. Мы можем нажать на + Add и увидеть, что мы можем
                отредактировать пункты меню, название 'меню' для этой базы выглядит не очень корректно, возможно за кадром изменю это.
                У нас есть все наши поля, а именно: название, описание, рецепт,
                калорийность и изображение. Настоящие блюда и их описания мы своруем с какого-нибудь сайта позже, а сейчас придумаем что-нибудь простое.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_adminpannel_6.png' %}" alt="startproject_adminpannel_6" class="python_img i_38">
            <p>Первое блюдо или вернее сказать первая строка таблицы (базы данных) под названием Menu создана. Все хорошо,
                кроме одного момента, если сейчас попытаться открыть изображение по ссылке в поле
                img мы получим ошибку, говорящую, что страница не найдена.</p>
            <p>Первая причина, по которой это произошло, изображение сохранилось по пути menu/images/indeyka.png.
                Нам нужно изменить это, пусть хранилище всех медиа файлов проекта будет в одной папке, с таим же названием 'media'.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_5.png' %}" alt="startproject_models_5" class="python_img i_39">
            <p>Добавим константу MEDIA_ROOT в файл settings.py, где и напишем путь, по которому
                мы будем хранить все файлы и еще константу MEDIA_URL. Это то название, которое будет
                подставляться в адресной строке, когда будет формироваться новый путь для нового изображения.
                Перезапустим сервер и пересохраним изображение вареной индейки. После этого в
                папке проекта создалась папка 'media', а уже внутри нее путь menu/images/indeyka.png.</p>
            <p>Папку для всех медиафайлов мы создали, а вот динамически формирующиеся адреса для
                этих файлов еще нет. Перейдем в главный файл urls.py.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_6.png' %}" alt="startproject_models_6" class="python_img i_40">
            <p>Импортируем settings и static и сформируем ссылку для каждого загружаемого изображения.
                Вернемся в админку, пересохраним изображения и попробуем по нему перейти.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_adminpannel_7.png' %}" alt="startproject_adminpannel_7" class="python_img i_41">
            <p>Изображение индейки теперь открывается и имеет свой путь, который мы создали.
                Теперь можно создавать еще несколько блюд, с разными изображениями и каждое изображение
                сохранится в папке и получит свой уникальный путь. Вот этим базы данных и хороши,
                мы настроили этот момент всего однажды, потратили на него не так много времени, а пользоваться им теперь можно сколько потребуется.
                Представляете сколько времени экономится тем, что мы избавили себя от
                необходимости вручную помещать изображения в нужный каталог, так еще теперь и не возникнет никаких конфликтов связанных
                с путем и мы автоматически сформируем путь для каждого изображения. А более этого всем содержимым баз данных мы, конечно,
                можем пользоваться для отображения этого содержимого на экране. Этим теперь и займемся.</p>
            <section class="little_title">Отображаем информацию из баз данных на сайте. Знакомство с Django.templates</section>
            <p>Как вы наверное помните к заглавной странице в файле urls.py мы можем обратиться
                пустыми одинарными кавычками. Давайте воспользуемся этим и отобразим всю информацию о вареной индейке на главной странице.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_7.png' %}"
                 alt="startproject_models_7" class="python_img i_42">
            <p>Рассмотрим скриншот. Первым делом вспомним как отображать информацию на главной странице. Импортируем файл views.py приложения
                menu в urls.py. Добавим еще одну функцию path, где путь будет вести на главную
                страницу, то есть пустые кавычки, а отображать по этому пути мы будем функцию
                написанную в файле views.py. Далее перейдем в файл views.py и создадим там функцию home,
                которая в обязательном порядке будет принимать параметр request. Возвращать эта функция будет
                функцию render, первым параметром в которой будет request, вторым шаблон, а третьим все
                объекты базы данных. Для того чтобы взять все объекты базы данным импортируем из
                файла models.py нашу базу данных Menu. Запись вида 'название базы данных.object.all()' возьмет все данные из
                базы данных. Сохраним всю эту информацию в переменную с одноименным названием,
                это условие не обязательно, но по мне так удобнее и добавим эту переменную в словарь в качестве значения, в качестве названия ключа я
                тоже предпочитаю тождественное слово. С этим закончили.</p>
            <p>Теперь подробнее остановимся на файле index.html, путь до него templates/menu этот момент мы разбирали в прошлом проекте.
                Стандартный шаблонизатор в django имеет название django templates, мы можем использовать другие шаблонизаторы, например,
                jinja2, но пока остановимся на стандартном шаблонизаторе. Их синтаксис все-равно ничем не отличается. Итак, мы хотим
                взять все данные из базы данных. Для этого будем пробегаться по ней в цикле. Синтаксис цикла в шаблонизаторах выглядит так:
            <br><br><code>&#123;% for x in (название переменной, в которой сохранены все объекты
                    модели, (menu в нашем случае)) %&#125;</code>
            <br>Тело цикла
            <br><code>&#123;% endfor %&#125;</code>
            <br><br>
            Далее, для обращения к объектам модели мы используем переменную 'x' в нашем случе 'meal' и через точку обращаемся к
                названию, которое мы придумали в файле models.py. Обращаемся мы ко всем этим
                объектам в двойных фигурных скобках. И к этим объектам применим стандартный html синтаксис.
                Таким образом обратимся ко всем объектам нашей модели. Обратите внимание на отображение изображения.
                Помещается изображение непосредственно в тэг img, где в параметре src мы указываем шаблонное обращение к объекту модели типа
                ImageField, у нас этот объект назван img, помимо этого добавим через точку
                параметр url, для того чтобы передавался полный путь до изображения. Теперь откроем главную страницу и посмотрим, что получилось.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_adminpannel_8.png' %}" alt="startproject_adminpannel_8" class="python_img i_43">
            <p>Увидим следующее. Я скачал другую картинку индейки, она мне больше нравится. Согласитесь, с базами данных работа над сайтом стала куда удобнее.</p>
            <p>А что будет, если добавить еще одно блюдо в наше меню?</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_adminpannel_9.png' %}" alt="startproject_adminpannel_9" class="python_img i_44">
            <p>Добавим в меню вареную курицу.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_8.png' %}" alt="startproject_models_8" class="python_img i_45">
            <p>Добавим в шаблон форматирование картинок, чтобы они все были равного размера. Пока что сделаем это прям внутри html разметки. И перейдем на главную страницу снова.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_adminpannel_10.png' %}" alt="startproject_adminpannel_10" class="python_img i_46">
            <p>Теперь она выглядит следующим образом. Каждая новая запись внесенная в базу данных теперь
                будет отображаться в одинаковом формате. Достаточно изменить разметку файла
                index.html и все записи добавленные в базу данных отображаться в заданном
                формате. Очень удобно.</p>
            <section class="little_title">Внешний вид. Статические файлы</section>
            <p>Давайте теперь добавим несколько блюд, я удалил поле с рецептом, все-таки мы тут учим django,
                а не создаем меню, которым кто-то будет пользоваться, поэтому для экономии времени ограничимся четырьмя полями.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_9.png' %}" alt="startproject_models_9" class="python_img i_47">
            <p>И еще добавил необязательный параметр blank в значении True, это будет означать, что поле теперь необязательно для заполнения.</p>
            <p>Сами варианты блюд, изображения и прочее я сворую в интернете.</p>
            <p>По итогу, я утомился даже от добавления девяти разновидностей меню, кажется,
                готовить я точно никогда не начну. Ладно работаем с тем, что есть, может позже добавлю еще что-нибудь.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_10.png' %}" alt="startproject_models_10" class="python_img i_48">
            <p>Добавил чуть-чуть внешнего вида. Это в данном случае нужно в первую очередь для навыка работы со статическими файлами. И еще я сейчас вынужден поработать за другим
                компьютером, поэтому в структуре проекта всего одна папка, папка этого сайта.</p>
            <p>Итак, статические файлы - любые файлы, к которым мы обращаемся не при помощи шаблонизатора,
                а просто помещаем их в проект из папки static, такими файлами могут быть изображения используемые,
                например, в качестве логотипа, иконка сайта, какой-нибудь pdf файл содержащий скажем политику конфиденциальности и прочие файлы. Почему из папки static?</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_11.png' %}" alt="startproject_models_11" class="python_img i_49">
            <p>Потому что в файле settings.py по умолчанию STATIC_URL равен 'static/', замените это имя на другое и тогда
                статические файлы будет нужно помещать в папку с новым именем переменной
                STATIC_URL, но зачем вам это нужно, static общепринято, понятно и удобно. Для
                структурирования файлов в папке static придерживайтесь такого же правила, как и
                для папки templates, называйте первую вложенную папку так же как называется ваше
                приложение. После этого условия размещайте статические файлы как угодно.</p>
            <p>Для добавления статических файлов в html файл добавьте строку <code>&#123;% load
                static %&#125;</code> и добавьте ее раньше, чем будут использованы сами файлы, например, добавьте
                эту строку в самом начале файле. css подключается к html стандартно через тэг link,
                за тем исключением, что в параметр href мы указываем путь к файлу с помощью записи
                <code>&#123;% static 'путь к файлу, имя папки static мы, конечно, игнорируем' %&#125;</code>.
                На остальных изменениях html файла заострять внимание не будем, просто привел файл к более менее сносной структуре.
                На css тоже заострять внимание не станем, тем более ничего особенного я тут придумывать не стал, такой css файл это 15 работы.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_adminpannel_11.png' %}" alt="startproject_adminpannel_11" class="python_img i_50">
            <p>Сделаю скриншот допустим из середины страницы. Получилось примерно следующее,
                ничего особенного, но этим я еще раз хотел показать насколько удобно использовать
                базы данных, теперь каждая новая запись в базе Menu будет отображаться на странице в таком же виде как и остальные записи.</p>
            <section class="little_title">Второе приложение</section>
            <p>Для второго приложения базы данных нам не понадобятся, но для практики и тут воспользуемся ими.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_12.png' %}" alt="startproject_models_12" class="python_img i_51">
            <p>Поэтому, для начала создадим модель и зарегистрируем ее. Пусть модель Week
                содержит одно поле, в этом поле будет храниться день недели.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_adminpannel_12.png' %}" alt="startproject_adminpannel_12" class="python_img i_52">
            <p>После этого вернемся в админку и добавим семь записей в модель Week. Каждая эта запись будет содержать только день недели.</p>
            <p>Не забудьте воспользоваться командами makemigrations и migrate для добавления модели в БД.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_13.png' %}" alt="startproject_models_13" class="python_img i_53">
            <p>После этого вернемся в файл urls.py и изменим его. Когда приложений появляется больше чем одно
                возникает проблема связанная с главным файлом urls.py. В каждом приложении файл
                с отображением стандартно имеет название views и обращаться к функциям этого файла разных
                приложений через views. становится невозможно. Более того приложений и путей в этих приложениях
                у большого проекта может быть огромное множество, и по итогу файл urls.py может оказаться сильно загроможденным.
                Для этого принято разграничивать пути по соответствующим приложениям. Для этого
                существует функция include(), перед использованием не забудьте ее импортировать из
                django.urls. В эту функцию мы передаем путь к файлу urls.py нашего приложения, предварительно
                файл urls.py необходимо создать в каждом приложении. Первым же параметром функции path() будет являться
                'главный' адрес приложения. Создадим эти файлы и заполним их.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_14.png' %}" alt="startproject_models_14" class="python_img i_54">
            <p>Сделаем это таким образом. Теперь на главной странице (http://127.0.0.1:8000/)
                будет располагаться приложение Menu, а по адресу (http://127.0.0.1:8000/week)
                будет располагаться приложение week.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_15.png' %}" alt="startproject_models_15" class="python_img i_55">
            <p>Создадим представление для views.py приложения week, точно так же как мы делали раньше.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_16.png' %}" alt="startproject_models_16" class="python_img i_56">
            <p>Для отображения второго приложения возьмем таблицу из bootstrap и немного ее изменим,
                тоже ничего необычного. Обратить внимание хотелось бы обратить тут только на использование
                баз данных для оглавления столбцов таблицы. В остальном останавливаться тут не на чем. Так же
                я добавил по кнопке для каждого приложения со ссылкой на другое для перехода
                между ними, но опять же подобное мы уже делали в первом сайте. Так же файлы index.html и style.css
                приложения menu я так же немного изменил, но совсем по мелочи, напоминаю, весь код можно найти на моем
                <a href="https://github.com/IlyaTsarkov/dietforurcle" class="links" target="_blink">github</a>. Давайте посмотрим, что из этого вышло.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_adminpannel_13.png' %}" alt="startproject_adminpannel_13" class="python_img i_57">
            <p>На заглавной странице прежнее приложении, только добавилась кнопка, которая переадресовывает нас на страницу второго приложения.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_adminpannel_14.png' %}" alt="startproject_adminpannel_14" class="python_img i_58">
            <p>Выглядит она вот так. И все так же кнопка, которая возвращает нас уже к первому приложению.</p>
            <p>Осталось как-то запрограммировать кнопки 'выбрать'. Постараемся сделать это максимально примитивным способом, чтобы не перегружать материал посвященный второму сайту.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_17.png' %}" alt="startproject_models_17" class="python_img i_59">
            <p>Например вот так. Добавим на месте каждого слова 'Выбрать' выпадающий список, элементами которого будут поля title модели Menu.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_models_18.png' %}" alt="startproject_models_18" class="python_img i_60">
            <p>А для того, чтобы пользоваться этой моделью приложения Menu в html файле приложения week достаточно
                импортировать ее в файл views.py приложения week, обратиться к ее содержимому с помощью objects.all() и
                зарегистрировать эту переменную в словаре функции render. Вот так просто можно
                пользоваться любыми моделями внутри любого приложения. Ну и теперь посмотрим на финальный вариант нашего приложения week.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/secondsite/startproject_adminpannel_15.png' %}" alt="startproject_adminpannel_15" class="python_img i_61">
            <p>Теперь на месте слова выбрать появился выпадающий список, при раскрытии которого мы видим
                названия всех добавленных блюд в приложение menu. При чем название каждого нового добавленного блюда в модель Menu будет отображаться в этом выпадающем списке.</p>
            <section class="little_title">Второй сайт готов</section>
            <p>При создании второго сайта мы закрепили материал освоенный в прошлом сайте и немного
                расширили свои знания, а также познакомились с моделями и панелью администратора. Как упоминалось выше
                подобный сайт можно довести до ума, посидев над ним денек-два и, конечно, обладая необходимыми навыками и
                на его примере можно объяснить еще многое, но на это у нас есть будущие проекты. Главная цель этого
                сайта показать насколько сильно модели важны при написании сайтов и насколько удобны они в использовании. В следующем сайте постараемся детальнее останавливаться на теории.</p>
            <p>Весь код этого сайта можно найти на моем <a href="https://github.com/IlyaTsarkov/dietforurcle" class="links" target="_blink">github</a>.</p>
            <p>Если вы захотите скачать сайт и доработать его, используйте login - admin2 и пароль - 1234 для авторизации в панель администратора,
                либо можете создать новые данные для авторизации командой createsuperuser.</p>
            <h3 class="h3_name">Регистрация. Третий сайт.</h3>
            <p>В третьем сайте уделим внимание форме регистрации и хранению данных зарегистрированных
                пользователей. Идея дла сайта пришла в голову во время работы над вторым сайтом, третий
                сайт будет похож по своей идее, но более практичен и полезен для программистов. Создадим сайт с
                регистрацией, а в личном кабинете каждого пользователя добавим возможность
                добавлять библиотеки python, которые хотелось бы выучить. Более подробно о
                функционале и возможностях этого сайта поговорим уже в процесс создания. А пока
                просто создадим пустую папку с новым проектом pythonpackagelearn. При создании
                боевых проектов так же советую проверять, нет ли уже на github проекта с названием,
                которе вы придумали.</p>
            <section class="little_title">Регистрация пользователей</section>
            <p>В любом только что созданном проекте уже есть некоторый предустановленный функционал для авторизации пользователей.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_1.png' %}" alt="thirdproject_code_1" class="python_img i_62">
            <p>Именно из этого приложения мы будем импортировать необходимые инструменты для работы с
                авторизацией. Но, конечно, наличия одного этого приложения нам недостаточно.</p>
            <p>Начнем стандартно с создания и регистрации приложения package.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_2.png' %}" alt="thirdproject_code_2" class="python_img i_63">
            <p>Затем зарегистрируем адрес signup/, создадим функцию signupuser и файл
                signupuser.html. Пока ничего нового.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_1.png' %}" alt="thirdproject_web_1" class="python_img i_64">
            <p>И видим мы по этому адресу ожидаемый результат. Теперь внесем несколько изменений и воспользуемся встроенной в django формой регистрации.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_3.png' %}" alt="thirdproject_code_3" class="python_img i_65">
            <p>напишем следующее. Импортируем из django.contrib.auth.forms форму регистрации UserCreationForm.
                А после добавим эту форму в словарь функции render и передадим ключ этого словаря в шаблон регистрации.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_2.png' %}" alt="thirdproject_web_2" class="python_img i_66">
            <p>Теперь по тому же адресу мы видим форму регистрации содержащую строку для ввода логина и
                два поля для первичного ввода пароля и для его подтверждения. Помимо этого есть текст
                с некоторыми правилами и описанием для этих полей. После этого остановим сервер и
                воспользуемся командой createsuperuser, панель администратора в этом сайте нам, конечно,
                понадобится. И не забудем произвести миграции, хоть ни одной собственной модели
                еще не создано, но команда migrate при только что созданном проекте необходима.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_4.png' %}" alt="thirdproject_code_4" class="python_img i_67">
            <p>Кстати, больше всего 'базовых' миграций связаны именно с авторизационным приложением. Перезапустим сервер и зайдем в панель администратора под администраторскими данными.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_3.png' %}" alt="thirdproject_web_3" class="python_img i_68">
            <p>В базе 'Users' будет содержаться информация об одном пользователе, только что созданном админе.</p>
            <p>Теперь немного кастомизируем шаблон и саму форму, чтобы вы не пугались, что этот
                вид единственный возможный у стандартной формы регистрации.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_5.png' %}" alt="thirdproject_code_5" class="python_img i_69">
            <p>У полей логина и пароля есть имена, для логина - username, для первого пароля - password1,
                а для второго - password2. Мы можем воспользоваться ими для легкой кастомизации формы регистрации.
                Существует еще запись 'имя_формы_регистрации.as_p' (в нашем случае было бы registerform.as_p), такая
                запись создала бы пробелы между блоками регистрации, пробелы это следствие
                обертывания компонентов формы в тэг p, попробуйте воспользоваться им, может и
                этого покажется достаточно, p, как я упомянул ранее,
                означит тэг p, можно написать также as_li и тогда компоненты формы будут
                представлены через тэг li, а еще есть .as_table, такая запись отобразит компоненты формы как
                ячейки таблицы, а конкретно в виде тэгов tr. Также обернем всю форму в тэг form с
                методом протокола HTTP - POST. И добавим кнопку для подтверждения регистрации.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_4.png' %}" alt="thirdproject_web_4" class="python_img i_70">
            <p>Вернемся по адресу signup/ и посмотрим, что получилось. Теперь форма выглядит более привычно. Попробуем зарегистрировать нового пользователя.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_5.png' %}" alt="thirdproject_web_5" class="python_img i_71">
            <p>При попытке регистрации мы увидим следующую ошибку. В этой ошибке говорится о
                недостающем CSRF токене, и предлагается запись для добавления его в шаблон.
                CSRF - вид атаки на посетителей веб-сайтов, заключается в создании визуально
                похожей формы на подменном сайте с целью сбора данных пользователей, и django
                заботится о безопасности наших посетителей самостоятельно.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_6.png' %}" alt="thirdproject_code_6" class="python_img i_72">
            <p>Вернемся в шаблон и добавим csrf токен в него. Теперь ошибки не будет, но
                разумеется кнопка 'регистрация' сейчас не создаст нового пользователя. Реализуем мы этот функционал в файле views.py.
                Но перед этим вспомним разницу между HTTP методами GET и POST.</p>
            <p>GET мы должны использовать, когда запросы не влияют на изменение системы, так, например, в первом сайте мы использовали
                GET, поскольку генерируемые данные нигде не хранились, также информация о GET
                запросах обычно отображается в
                адресной строке, это тоже важный момент связанный с конфиденциальностью, о
                котором не стоит забывать.
            Также запомните каждый раз, когда вы пишете какой-нибудь запрос в адресной строке и
                нажимаете ввод вы используйте GET метод.
            <br>POST нужно использовать в остальных случаях, то есть тогда, когда вместе с
                запросом должны произойти какие-нибудь изменения на серверной части сайта. Добавление нового пользователя является ярким примером такого запроса.</p>
            <p>Теперь, когда мы понимаем разницу, реализуем возможность регистрации.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_7.png' %}" alt="thirdproject_code_7" class="python_img i_73">
            <p>Начнем с такого кода. Как упоминалось выше, при переходе на страницу используется
                метод GET, воспользуемся этим пониманием и при переходе по адресу signup/ будем
                показывать пользователю страницу с формой регистрации. В противном случае, то
                есть в случае использования метода POST, мы явно указали метод POST для формы в
                шаблоне. Так вот, в случае POST мы будем создавать объект пользователя, для этого
                импортируем модель User из django.contrib.auth.models, а после воспользуемся функцией
                create_user(). Первым параметром передадим в нее значение поля username, а вторым
                - значение поля password1, ранее мы разобрались, что это за поля. Присваивать только что созданного пользователя
                будем переменной user, а после сохранять его функцией save(). Помимо этого перед
                созданием нового пользователя сделаем проверку совпадения паролей в полях password1 и password2.</p>
            <p>Попробуем создать пользователя теперь.</p>
            <img src="i{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_6.png' %}" alt="thirdproject_web_6" class="python_img i_74">
            <p>Введем логин и одинаковый пароль.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_7.png' %}" alt="thirdproject_web_7" class="python_img i_75">
            <p>Мы увидим ошибку, в которой будет сказано, что мы ничего не возвращаем.
                Действительно сейчас мы только создаем нового пользователя, но после этого
                действия мы никуда не перенаправляемся или хотя бы не остаемся на той же самой
                странице, у нас пока просто-напросто не написано никакого подобного поведения. Но
                если мы теперь снова вернемся в панель администратора и перейдем в базу пользователей.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_8.png' %}" alt="thirdproject_web_8" class="python_img i_76">
            <p>Мы увидим, что только что созданный пользователь в этой базе появился.</p>
            <p>Мы создали работающую форму регистрации.</p>
            <section class="little_title">Дорабатываем форму регистрации. Обработка ошибок</section>
            <p>Осталось еще несколько важных моментов связанных с регистрацией пользователей. Например,
                сейчас у нас написано условие проверки тождественности паролей, но поведение для ситуации, при которой пароли не совпадают, у нас не написано.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_8.png' %}" alt="thirdproject_code_8" class="python_img i_77">
            <p>Исправить это можно следующим образом. Добавим в условие else вывод той же самой
                страницы регистрации, но добавим в словарь функции render() новое значение с
                ключом, например, 'error', а значением этого ключа будет сообщение говорящее о
                несовпадении паролей. И выводить это значение в том шаблоне, который вызывается при попадании в оператор else.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_9.png' %}" alt="thirdproject_web_9" class="python_img i_78">
            <p>И теперь при попытке регистрации с неверным паролем мы снова попадаем на страницу
                регистрации, только теперь на ней появляется сообщение об ошибке.</p>
            <p>Так же у нас осталась еще одна проблема, при попытке создания пользователя с именем, которое уже есть в системе мы также получаем ошибку.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_10.png' %}" alt="thirdproject_web_10" class="python_img i_79">
            <p>Ошибку типа IntegrityError. Ошибка сообщает нам, что имя неуникально, но хотелось бы сообщать об этом и пользователям. Мы можем обработать этот тип ошибки.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_9.png' %}" alt="thirdproject_code_9" class="python_img i_80">
            <p>Воспользуемся для ее обработки блоками try и except, а возвращать в случае возникновения ошибки тот же шаблон регистрации с ошибкой, но текст ошибки при этом изменим.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_11.png' %}" alt="thirdproject_web_11" class="python_img i_81">
            <p>Теперь при попытке создания пользователя с именем, которое уже зарегистрировано в базе данных мы увидим соответсвующее сообщение об ошибке.</p>
            <section class="little_title">Регистрация. Авторизация. Выход</section>
            <p>Что осталось еще? Нам явно не хватает одной только страницы с регистрацией,
                зачастую на сайтах после регистрации нас перенаправляют в личный кабинет, откуда
                есть возможность выхода. А вообще нам не помешала бы домашняя страница, на которой можно
                зарегистрироваться либо авторизоваться. Кстати, возможности авторизации у нас
                по-прежнему нет. Давайте разберемся со всеми этими моментами.</p>
            <p>А еще я вернулся за свой компьютер.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_10.png' %}" alt="thirdproject_code_10" class="python_img i_82">
            <p>Начнем с создания страницы личного кабинета. Пока просто создадим путь для нее в
                urls.py и напишем функцию для этого пути, которая будет ссылаться на шаблон, который пока содержит всего одну надпись.
                После этого в функции signupuser добавим две строки (17 и 18 на скриншоте), первым делом
                обратимся к заранее импортированной функции login(), эта функция присоединяет пользователя к
                текущей сессии, принимать эта функция должна объект Http запроса и объект User. После присоединения
                нового пользователя к сессии будем перенаправлять этого пользователя на только что созданную страницу
                личного кабинета. Для этого воспользуемся функцией redirect, не забудьте сначала ее импортировать,
                принимает эта функция имя страницы, на которую нужно перенаправиться.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_12.png' %}" alt="thirdproject_web_12" class="python_img i_83"><br>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_13.png' %}" alt="thirdproject_web_13" class="python_img i_84">
            <p>Теперь после введения данных пользователя и нажатия на кнопку 'Регистрация', которых еще нет в базе данных, нас будет перенаправлять на страницу личного кабинета.</p>
            <p>Теперь мы авторизованы на сайте под данными пользователя vova, давайте попробуем теперь перейти в панель администратора.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_14.png' %}" alt="thirdproject_web_14" class="python_img i_85">
            <p>При попытке входа в панель администратора мы увидим сообщение, что мы пытаемся
                войти как vova, поэтому для использования кабинета администратора пользователь
                должен быть создан именно командой createsuperuser, у других пользователей, как видно, доступа к этому кабинету нет.</p>
            <p>Хорошо, личный кабинет, хоть пока и пустой, мы сделали. Вспомните, что обычно отображается в
                каждом личном кабинете? В каждом, или почти в каждом, личном кабинете где-нибудь вверху отображается
                статус авторизованности, обычно это просто ваш никнейм, под которым вы
                авторизовались. Давайте сделаем то же самое и на нашем сайте.</p>
            <p>Во-первых, в данном сайте я пока не задействовал имя index.html (либо base.html) для
                какого-нибудь шаблона. Дело в том, что это имя принято использовать как имя дла главного шаблона
                сайта, в этом шаблоне обычно предписаны какие-то настройки интерфейса общие для
                каждой страницы сайта. А все остальные шаблона наследуются от этого главного
                шаблона. Давайте создадим такой шаблон.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_11.png' %}" alt="thirdproject_code_11" class="python_img i_86">
            <p>Пока не станем добавлять ничего нового, а просто добавим шаблон index.html и
                отредактируем наши шаблоны в зависимости от этого шаблона. Во-первых, перенесем
                всю стандартную структуру html:5 документа в этот базовый шаблон. А после
                создадим в нем два блока, первый для тэга title, второй для содержимого тэга
                body. Блоки всегда имеют одинаковую структуру - <br><code>&#123;% block 'имя
                    блока(придумываем сами)' %&#125;&#123;% endblock %&#125;</code>.<br> Взглянем на блок для title,
                теперь в наследуемых шаблонах нам достаточно поместить внутрь этого блока желаемый заголовок и этот
                заголовок будет подставлен внутрь тэга title базового шаблона. Для того чтобы унаследоваться от главного шаблона используется
                запись - <br><code>&#123;% extends 'путь к базовому шаблону' %&#125;</code>.<br> С контентным блоком ситуация аналогичная.</p>
            <p>Теперь расширим базовый шаблон, добавив информацию, которая будет отображаться на каждой странице.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_12.png' %}" alt="thirdproject_code_12" class="python_img i_87">
            <p>Сделаем это следующим образом. функция is_authenticated() возвращает True в случае авторизованности на сайте. Пускай в случае
                авторизованности мы будем видеть текст - 'Вы вошли как (имя пользователя)' и кнопку с выходом из учетной записи, а в
                противном случае будем видеть кнопку регистрации и авторизации. Ссылки пока
                забьем заглушками.</p>
            <p>Теперь вернемся например на страницу регистрации.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_15.png' %}" alt="thirdproject_web_15" class="python_img i_88">
            <p>Сверху теперь мы видим информацию о статусе авторизованности и кнопку выхода, то
                же самое мы увидим перейдя на страницу личного кабинета.</p>
            <p>Теперь давайте сделаем кнопку выхода работающей. Куда должна перенаправлять нас кнопка выхода
                из учетной записи? Скорее всего на домашнюю страницу сайта, на данный момент такой страницы у нас нет
                и мы можем перенаправляться на страницу регистрации, но поскольку домашняя страница нам все-равно понадобится давайте сразу создадим ее.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_13.png' %}" alt="thirdproject_code_13" class="python_img i_89">
            <p>Создадим стартовую страницу с небольшим описанием сайта, сократим длинное название pythonpackagelearn до PyPaLearn.
                Делали мы это уже много раз, поэтому останавливаться тут не на чем.</p>
            <p>Помимо этого сразу создадим путь для страницы logout/ и перейдем к написанию функции для этого пути.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_14.png' %}" alt="thirdproject_code_14" class="python_img i_90">
            <p>Функцию опишем следующим образом. Импортируем функцию logout() и выполняться эта функция будет только в случае
                инициализации POST метода, как вы помните при любом вводе запроса в адресной строке инициализируем GET метод,
                поэтому POST указать нам нужно явно в шаблоне. И после выхода из учетной записи мы будем
                переадресовываться на домашнюю страницу. Не забудьте про &#123;% csrf_token %&#125;.</p>
            <p>После обернем кнопку выхода в форму, где действием будет переадресация на path() с именем 'logoutuser'. Тэги 'a' можно убрать, они тут лишние.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_16.png' %}" alt="thirdproject_web_16" class="python_img i_91"><br>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_17.png' %}" alt="thirdproject_web_17" class="python_img i_92">
            <p>Теперь при нажатии кнопки 'Выйти' мы будем выходить из аккаунта и перенаправляться на домашнюю страницу.</p>
            <p>Осталось разобраться с авторизацией.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_15.png' %}" alt="thirdproject_code_15" class="python_img i_93">
            <p>Первым делом сделаем, чтобы кнопка 'Зарегистрироваться' вела на signupuser/ и
                займемся кнопкой 'Войти'.</p>
            <p>Для начала добавим еще одну функцию path() для loginuser. И напишем функцию loginuser.
                Для авторизации также будем пользоваться встроенной формой - AuthenticationForm,
                импортируем ее также из django.contrib.auth.forms, ее поля имею название username -
                для логина и password - для пароля. В случае GET метода мы будем отправлять на страницу
                авторизации, в случае POST - будем пользоваться функцией authenticate, импортируется она из
                django.contrib.auth, первым параметром эта функция принимает request, далее идут username и password.
                Эта функция, как вы наверное догадались, ищет есть ли такие данные в базе данных. Возвращает эта функция
                объект User. Присвоим результат работы этой функции переменной user, далее в
                случае отсутствия введенных данных будем возвращать пользователя на ту же страницу
                авторизации, но дополнительно выведем сообщение ошибки. А в случае наличия введенных
                данных в базе данных будем применять функцию login() и перенаправлять пользователя в личный кабинет.</p>
            <p>Шаблон для loginuser будет почти такой же, как и для signupuser, заменим
                заголовок, содержимое тэга h1 ну и поля ввода данных будем брать уже от AuthenticationForm.
                В шаблоне index.html кнопка войти пусть перенаправляет нас на loginuser/.</p>
            <p>Теперь посмотрим, что получилось.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_18.png' %}" alt="thirdproject_web_18" class="python_img i_94"><br>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_19.png' %}" alt="thirdproject_web_19" class="python_img i_95"><br>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_20.png' %}" alt="thirdproject_web_20" class="python_img i_96">
            <p>При попытке авторизации под неверными данными мы видим сообщение о неправильности
                введенных данных, а в случае верных данных мы перенаправляемся в личный кабинет.</p>
            <p>Таким образом, мы создали с вами полностью работающую систему аутентификации с возможностью регистрации, авторизации и выхода из системы.</p>
            <section class="little_title">Модель. Углубление в базы данных</section>
            <p>Мы создали форму регистрации. Теперь мы должны приступить к созданию модели для
                работы с библиотеками, которые хотелось бы изучить конкретному авторизованному на
                сайте пользователю. Мы понимаем как создаются модели хранящие какие-нибудь
                записи, пусть мы знакомы не со всеми видами полей, но это мы еще наверстаем, но есть одно поле, которе заметно выделяется на
                фоне других. Это поле - ForeignKey или внешний ключ. Этот внешний ключ необходим
                для взаимодействия между базами данных.
                Давайте немного отвлечемся и разберемся боле подробно с базами данных здесь.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_16.png' %}" alt="thirdproject_code_16" class="python_img i_97">
            <p>По умолчанию любой новый созданный проект на django использует СУБД (СУБДТ -
                система управления базами данных) -
                sqlite3. Также в папке с проектом есть файл db.sqlite3, в этом файле и хранится вся база данных нашего проекта.
                Давайте заглянем внутрь этой базы и посмотрим как это выглядит.</p>
            <p>Для установки sqlite3 и программу для просмотра баз используйте следующие команды:
            <br><code>sudo apt update</code>
            <br><code>sudo apt install sqlite3</code>
            <br><code>sudo apt install sqlitebrowser</code>
            <br>Далее откройте у себя на устройстве появившееся после установки приложение DB Browser for SQLite.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_21.png' %}" alt="thirdproject_web_21" class="python_img i_98">
            <p>Вы увидите перед собой такое окно, сначала оно будет пустое, нажмите Open Database и выберите
                файл db.sqlite3 нашего проекта. Мы увидим 11 таблиц, это те таблицы, которые по умолчанию содержит каждый проект.
                Обратите внимание на столбец Schema, в этом столбце написана схема создания этой конкретной таблицы и у каждой из этих
                таблиц есть поле 'id'. При работе с чистым SQL это поле мы создаем вручную, а при работе с базами данных в django оно создается
                автоматически. Обычно это поле имеет параметры представленные на скриншоте, а
                именно: название - id, тип данных этого поля - integer,
                то есть целое число, NOT NULL - означает, что поле не может оставаться пустым и PRIMARY KEY AUTOINCREMENT - автозаполняемый первичный ключ,
                автозаполение обычно происходит в стандартной целочисленной положительной
                последовательности.</p>
            <p>Теперь давайте откроем какую-нибудь таблицу, например auth_user, где хранится информация о наших зарегистрированных пользователях.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_22.png' %}" alt="thirdproject_web_22" class="python_img i_99">
            <p>Для этого перейдите в Browse Data и в списке таблиц выберите auth_user. Мы видим трех пользователей сайта,
                два, которых мы регистрировали через форму и один админ. Интересно нам тут поле id, как видно оно заполняется от
                единицы и далее, у каждой новой записи в этой таблице это значение будет
                увеличиваться на один, как и в других таблицах.</p>
            <p>Теперь, когда мы немного заглянули внутрь баз данных, вернемся к проекту для создания новой
                модели, а после обратно возвратимся в DB Browser for SQLite. И еще думаю теперь для всех окончательно стало понятно, что базы данных это обычные таблицы.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_17.png' %}" alt="thirdproject_code_17" class="python_img i_100">
            <p>Создадим для начала такую модель. С CharField и TextField мы уже знакомы. Кстати,
                параметр max_length поля CharField является обязательным и если него не заполнить это значение будет равно 200.
                Далее идет ранее не использованное поле URLField, как понятно из названия это поле для ссылки, и это поле
                наследуется от CharField, так что параметр max_length для него также является
                обязательным, в данном случае
                оно осталось пустым значит максимальная длина ссылки будет 200 символов. И
                последнее поле ForeignKey, для его использования импортируем модель User, это та
                самая таблица auth_user. В этом поле написано, что мы будем прикреплять запись к
                конкретному пользователю, и прикрепляться эта запись будет
                именно по id пользователя. Параметр on_delete=models.CASCADE означает каскадное удаление всех объектов ссылающийся на этот объект.
                В данном случае, при удалении пользователя будут удалены все записи этого пользователя.</p>
            <p>Метод __str__ написанный ниже отвечает за отображение записей модели в панели
                администратора. Сейчас покажу, что я имею в виду.
                И не забудьте зарегистрировать модель в admin.py после чего произвести миграции.</p>
            <p>Теперь запустим сервер и перейдем в панель администратора.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_23.png' %}" alt="thirdproject_web_23" class="python_img i_101">
            <p>Создадим новую запись в этой модели и прикрепим ее к пользователю vova.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_24.png' %}" alt="thirdproject_web_24" class="python_img i_102">
            <p>Отображается запись в этой модели как Django, за это и отвечает метод __str__.</p>
            <p>Итак, запись в модели мы создали, теперь вернемся в DB Browser for SQLite и взглянем на эту таблицу.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_25.png' %}" alt="thirdproject_web_25" class="python_img i_103">
            <p>Перед нами таблица со всеми нашими полями, еще тут видно поле created, которе при создании модели мы описали, но при
                создании записи в этой модели в админке мы не видели этого поля. Произошло это
                потому, что это поля заполняется автоматически и мы не можем его менять. Но интересует нас тут другое. Поле id и
                user_id, содержат эти поля цифру 3, хотя
                запись в таблице всего одна. Это и есть та самая связь с помощью поля ForeignKey,
                если вернуться к скриншоту таблицы auth_user
                мы увидим, что vova имеет id 3. Таким образом сайт будет понимать какие записи
                нужно отобразить в личном кабинете каждого конкретного пользователя.</p>
            <p>Давайте создадим еще одну запись привязанную к Вове и посмотрим как это повлияет на таблицу.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_26.png' %}" alt="thirdproject_web_26" class="python_img i_104">
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_27.png' %}" alt="thirdproject_web_27" class="python_img i_105">
            <p>user_id по прежнему равен 3, все логично модель прикреплена к тому же пользователю, а вот id увеличился на 1,
                на самом деле это тоже логично, ведь к записям конкретного пользователя нам тоже
                нужно обращаться по какому-то уникальному ключу.</p>
            <p>Надеюсь теперь, заглянув внутрь баз данных, вы лучше понимаете устройство баз
                данных и как возможно осуществлять связь между ними. Конечно, рассказать о базах данных можно еще многое. Но, как говорится, всему свое время.</p>
            <section class="little_title">Работа с моделями не через панель администратора. forms.py</section>
            <p>Работать с записями через панель администратора мы научились, но хотелось бы, чтобы авторизованный пользователь,
                с обычными правами, сам мог добавлять записи. В этом блоке этим и займемся.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_18.png' %}" alt="thirdproject_code_18" class="python_img i_106">
            <p>Для добавления новых записей в базу данных нам нужна форма, в которую мы будем
                записывать данные находясь на соответствующей странице сайта. Начнем с создания
                адреса для этой страницы (create/) и соответствующей функции (createnewpackage).
                Далее в папке с приложением package создадим файл forms.py. В этот файл нам нужно импортировать
                ModelForm из django.forms и нашу ранее созданную модель Package. В этом файле создаются формы,
                которые будут отображаться непосредственно для пользователя. Поэтому содержать
                эти формы должны те же поля, которые содержат модели, в которые мы хотим отправить введенную в эти поля информацию. Создадим класс NewPackage и
                унаследуем его от ModelForm. Благодаря наследованию от этого класса и создаются поля, которые можно заполнять. Далее
                нам нужен вложенный метакласс, как вы помните в python что-то более локальное
                наследуется от чего-то более глобального, так
                вот метаклассы в этой цепочки самые глобальные объекты, метаклассы отвечают за конструирование его дочерних классов.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_19.png' %}" alt="thirdproject_code_19" class="python_img i_107">
            <p>Метаклассом ModelForm является ModelFormMetaclass. Напоминаю, перейти к коду какой-то
                модуля django достаточно кликнуть по нему с нажатой клавишей ctrl. А сам ModelFormMetaclass
                участвует в создании полей модели, не в одиночку, конечно, но в том, что касается моделей, ноги растут именно от этого метакласса.
            <br>В качестве модели используем нашу модель Package, а из полей оставим только те,
                которые пользователь может заполнять,
                поля с датой и временем создания записи, а так же поле привязки к пользователю нам не нужны.</p>
            <p>Теперь вернемся в views.py и создадим отображение создания записи. Для этого сначала импортируем из forms.py NewPackage.
                В случае GET метода будем возвращать страницу создания записи, в файле createnewpackage.html воспользуемся полями формы NewPackage,
                а в остальном она пока пусть будет примерно такая же, как loginuser.html и signupuser.html. В случае POST метода сохраним все
                переданные записи в переменную form, нам тут достаточно только записи
                request.POST, без указания в квадратных скобках конкретных
                полей, django в данном случае сам понимает в какое поле какую запись надо добавить. Для сохранения записи в базу данных используется
                метод .save(). Параметр commit в значении False вернет объект, который еще не сохранен в базе данных. Этот возвращенный объект, который
                уже содержит в себе записи мы сохраним в еще одну переменную, newpackage в нашем
                случае. И уже после этого сопоставим запись с пользователем,
                который ее создал. А создал ее тот пользователь, под которым мы авторизованы на
                сайте. Только теперь мы можем вызвать метод save() без
                параметра commit (commit=True значение по умолчанию) и сохранить запись в базу
                данных. Try Except тут нужен на тот случай, если пользователь
                вдруг введет в поле title или в полу url количество символов превышающее
                ограничение, в случае с url понадеемся, что такое вообще не возможно,
                хотя по-хорошему можно было бы обработать и это, а вот с полем title
                это более вероятно, поэтому текст ошибки оставим именно со словом title. На ваше
                усмотрение его текст можно сделать и более нейтральным,
                затрагивающим поля title и url сразу. Ну и перенаправляться после нажатия кнопки
                'создать' мы будем в личный кабинет.</p>
            <p>Теперь перейдем по адресу create/ и посмотрим на результат.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_28.png' %}" alt="thirdproject_web_28" class="python_img i_108">
            <p>Получилось так. Теперь мы можем добавлять записи в базу данных будучи пользователем с
                обычными правами. Попробуем добавить запись и вернуться в панель администратора, чтобы убедиться в создании новой записи и в том, что она принадлежит именно Вове.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_28.png' %}" alt="thirdproject_web_29" class="python_img i_109">
            <p>Запись создана и принадлежит она именно Вове. Все работает.</p>
            <section class="little_title">Вывод записей в личном кабинете</section>
            <p>У нас интерфейс создания записей, но личный кабинет по прежнему пустой.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_20.png' %}" alt="thirdproject_code_20" class="python_img i_110">
            <p>Добавим модель Package в функцию personal_cabinet, только брать мы будем не все записи.
                Мы применим новый для нас метод - filter().  Данный фильтр проверяет какой user сейчас авторизован,
                и брать записи мы будем именно этого пользователя. Метод order_by() позволяет
                отсортировать записи по какому-нибудь признаку. Например, тут мы сортируем записи пользователя по алфавитному порядку, а
                минус перед словом title означает, что сортировать нужно в обратном порядке. А почему тогда буква 'a' стоит раньше буквы 'D',
                если сортировка в обратном алфавитном порядке? Потому что заглавные буквы в последовательности букв стоят раньше, чем прописные.</p>
            <p>В html файле для данной функции ничего нового для нас нет. Единственное можно
                обратить внимание на строку для ссылки на документацию, это поле мы сделали
                необязательным для заполнения, и если это поле останется пустым мы все равно
                увидим содержимое тэга 'a' и
                при клике на эту ссылку мы никуда переходить не будем. Это, конечно, неправильно. Поэтому вначале сделаем проверку
                на наличие содержимого в этом поле с помощью &#123;% if %&#125;&#123;% endif %&#125;.</p>
            <p>Вернемся теперь в кабинет Вовы, вторую запись я тоже предварительно перевел на него для наглядности.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_30.png' %}" alt="thirdproject_web_30" class="python_img i_111">
            <p>Выглядит личный кабинет теперь так. Содержимого тэга 'a' для второй записи действительно нет. А теперь сменим пользователя.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_31.png' %}" alt="thirdproject_web_31" class="python_img i_112">
            <p>Зайдем допустим под Ильей. И увидим, что в кабинете этого пользователя действительно пусто.</p>
            <p>С этим разобрались.</p>
            <section class="little_title">Личная страница для каждой записи</section>
            <p>Давайте лучше в личном кабинете будет выводить только названия записей и сделаем их кликабельными.
                А при клике на название будем попадать на личную страницу каждой записи, где уже
                и будет описание, ссылка, дата создания и все, что вы захотите придумать.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_21.png' %}" alt="thirdproject_code_21" class="python_img i_113">
            <p>Обратим внимание на путь для новой страницы, с таким мы еще не сталкивались, знаки больше меньше означают,
                что их содержимое воспринимается как параметр, а int перед этой записью приводит этот параметр к целочисленному значению.
                Раз это параметр, то мы можем, а в случае таких параметров даже должны, где-то этот параметр использовать. И использовать
                мы должны его в функции-представлении для этого пути, передается параметр вместе с request. В этот параметр попадает то, что
                мы пишем через / после запроса, например в package/this, this в данном случае
                поступило бы в переменную package_pk. Но нас интересуют, конечно, не слова, а нас
                интересуют pk, то есть primary key, уникальный идентификатор каждой записи.
                Его мы будем преобразовывать к целочисленному типу и выводит после /.</p>
            <p>Создадим функцию-представление во views.py. Для этой функции импортируем get_object_or_404,
                тоже новая для нас функция. Эта функция возвращает пользователю 404, когда будет передан
                несуществующий адрес записи. Принимать эта функция будет первым параметром модель, а вторым будет
                принимать первичный ключ записи из этой модели. Сохраним результат работы этой
                функции в переменную и
                через эту переменную будет обращаться к содержимому записи в соответствующем html
                файле.</p>
            <p>В этом html нет для нас ничего нового. Останавливаться на нем не станем. И файл personal_cabinet.html нам тоже нужно немного изменить.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_32.png' %}" alt="thirdproject_web_32" class="python_img i_114">
            <p>Теперь в личном кабинете мы видим только кликабельные названия, который ведут на
                личную страницу каждой записи. Запись asincio имеет описание и ссылку и они выводятся на экране, а запись
                Django имеет только название и в поле 'описание' мы видим 'Тут пока ничего нет...', а поле с ссылкой вообще не видно.</p>
            <section class="little_title">Редактирование и удаление записей</section>
            <p>Осталось добавить недостающий функционал.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_code_22.png' %}" alt="thirdproject_code_22" class="python_img i_114">
            <p>Создадим два пути, для редактирования и для удаления. По скольку к этим страницам
                мы обращаемся со страницы личной записи, то url приписку адреса мы пишем после
                переменной адреса. На странице для редактирования воспользуемся формой
                NewPackage, параметр instance свяжет модель редактирование с содержимым конкретной модели. После внесения изменения будем
                сохранять форму и перенаправляться на страницу личного кабинета и поскольку на странице редактирования пользователь также может использовать
                больше символов, чем доступно, то эту гипотетическую ситуацию мы обработаем. Для удаления создадим функцию-представление, которая в случае POST метода
                будет применять метод .delete(), вместо save(). И находиться эта кнопка пусть будет там же где мы редактируем запись.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_33.png' %}" alt="thirdproject_web_33" class="python_img i_115">
            <p>Теперь у нас есть личный кабинет со списком записей, с возможностью их просмотра и редактирования и с возможностью их удаления.</p>
            <p>Давайте на этом закончим с функционалом, добавить можно еще много, но основные инструменты для этого мы с вами уже освоили, так что дальше все зависит от вашей фантазии.</p>
            <section class="little_title">Внешний вид</section>
            <p>Осталось заняться оформлением нашего сайта. Много тратить на это время не стану, набросаю простенький дизайн с помощью bootstrap и css.</p>
            <img src="{% static 'alls_articles/articles/django/pictures/thirdsite/thirdproject_web_34.png' %}" class="python_img i_116">
            <p>Вот так теперь выглядит личный кабинет, посмотреть на весь сайт можно скачать весь проект с моего github.</p>
            <section class="little_title">Третий сайт готов</section>
            <p>За эти три сайта мы познакомились со всем 'скелетом' возможностей django. Освоив
                этот материал и хотя бы повторив за мной все, что тут описано, вы уже умеете создавать
                полноценные сайты на django. На этом обучающие материалы по django не заканчиваются, но далее мы не станем
                писать полноценные сайты, а будем заострять внимание на более тонких моментах связанных с теорией.</p>
        </div>
    </div>
{% endblock %}